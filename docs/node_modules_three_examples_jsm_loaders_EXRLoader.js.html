<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/three/examples/jsm/loaders/EXRLoader.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node_modules/three/examples/jsm/loaders/EXRLoader.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
	DataTextureLoader,
	DataUtils,
	FloatType,
	HalfFloatType,
	LinearEncoding,
	LinearFilter,
	RedFormat,
	RGBAFormat
} from 'three';
import * as fflate from '../libs/fflate.module.js';

/**
 * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
 * Supports reading as UnsignedByte, HalfFloat and Float type data texture.
 *
 * Referred to the original Industrial Light &amp; Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation, so I have preserved their copyright notices.
 */

// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */

// // TinyEXR contains some OpenEXR code, which is licensed under ------------

// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light &amp; Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light &amp; Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////

// // End of OpenEXR license -------------------------------------------------

class EXRLoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	parse( buffer ) {

		const USHORT_RANGE = ( 1 &lt;&lt; 16 );
		const BITMAP_SIZE = ( USHORT_RANGE >> 3 );

		const HUF_ENCBITS = 16; // literal (value) bit length
		const HUF_DECBITS = 14; // decoding bit size (>= 8)

		const HUF_ENCSIZE = ( 1 &lt;&lt; HUF_ENCBITS ) + 1; // encoding table size
		const HUF_DECSIZE = 1 &lt;&lt; HUF_DECBITS; // decoding table size
		const HUF_DECMASK = HUF_DECSIZE - 1;

		const NBITS = 16;
		const A_OFFSET = 1 &lt;&lt; ( NBITS - 1 );
		const MOD_MASK = ( 1 &lt;&lt; NBITS ) - 1;

		const SHORT_ZEROCODE_RUN = 59;
		const LONG_ZEROCODE_RUN = 63;
		const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;

		const ULONG_SIZE = 8;
		const FLOAT32_SIZE = 4;
		const INT32_SIZE = 4;
		const INT16_SIZE = 2;
		const INT8_SIZE = 1;

		const STATIC_HUFFMAN = 0;
		const DEFLATE = 1;

		const UNKNOWN = 0;
		const LOSSY_DCT = 1;
		const RLE = 2;

		const logBase = Math.pow( 2.7182818, 2.2 );

		function reverseLutFromBitmap( bitmap, lut ) {

			let k = 0;

			for ( let i = 0; i &lt; USHORT_RANGE; ++ i ) {

				if ( ( i == 0 ) || ( bitmap[ i >> 3 ] &amp; ( 1 &lt;&lt; ( i &amp; 7 ) ) ) ) {

					lut[ k ++ ] = i;

				}

			}

			const n = k - 1;

			while ( k &lt; USHORT_RANGE ) lut[ k ++ ] = 0;

			return n;

		}

		function hufClearDecTable( hdec ) {

			for ( let i = 0; i &lt; HUF_DECSIZE; i ++ ) {

				hdec[ i ] = {};
				hdec[ i ].len = 0;
				hdec[ i ].lit = 0;
				hdec[ i ].p = null;

			}

		}

		const getBitsReturn = { l: 0, c: 0, lc: 0 };

		function getBits( nBits, c, lc, uInt8Array, inOffset ) {

			while ( lc &lt; nBits ) {

				c = ( c &lt;&lt; 8 ) | parseUint8Array( uInt8Array, inOffset );
				lc += 8;

			}

			lc -= nBits;

			getBitsReturn.l = ( c >> lc ) &amp; ( ( 1 &lt;&lt; nBits ) - 1 );
			getBitsReturn.c = c;
			getBitsReturn.lc = lc;

		}

		const hufTableBuffer = new Array( 59 );

		function hufCanonicalCodeTable( hcode ) {

			for ( let i = 0; i &lt;= 58; ++ i ) hufTableBuffer[ i ] = 0;
			for ( let i = 0; i &lt; HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;

			let c = 0;

			for ( let i = 58; i > 0; -- i ) {

				const nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );
				hufTableBuffer[ i ] = c;
				c = nc;

			}

			for ( let i = 0; i &lt; HUF_ENCSIZE; ++ i ) {

				const l = hcode[ i ];
				if ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ &lt;&lt; 6 );

			}

		}

		function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {

			const p = inOffset;
			let c = 0;
			let lc = 0;

			for ( ; im &lt;= iM; im ++ ) {

				if ( p.value - inOffset.value > ni ) return false;

				getBits( 6, c, lc, uInt8Array, p );

				const l = getBitsReturn.l;
				c = getBitsReturn.c;
				lc = getBitsReturn.lc;

				hcode[ im ] = l;

				if ( l == LONG_ZEROCODE_RUN ) {

					if ( p.value - inOffset.value > ni ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					getBits( 8, c, lc, uInt8Array, p );

					let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
					c = getBitsReturn.c;
					lc = getBitsReturn.lc;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				} else if ( l >= SHORT_ZEROCODE_RUN ) {

					let zerun = l - SHORT_ZEROCODE_RUN + 2;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				}

			}

			hufCanonicalCodeTable( hcode );

		}

		function hufLength( code ) {

			return code &amp; 63;

		}

		function hufCode( code ) {

			return code >> 6;

		}

		function hufBuildDecTable( hcode, im, iM, hdecod ) {

			for ( ; im &lt;= iM; im ++ ) {

				const c = hufCode( hcode[ im ] );
				const l = hufLength( hcode[ im ] );

				if ( c >> l ) {

					throw new Error( 'Invalid table entry' );

				}

				if ( l > HUF_DECBITS ) {

					const pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];

					if ( pl.len ) {

						throw new Error( 'Invalid table entry' );

					}

					pl.lit ++;

					if ( pl.p ) {

						const p = pl.p;
						pl.p = new Array( pl.lit );

						for ( let i = 0; i &lt; pl.lit - 1; ++ i ) {

							pl.p[ i ] = p[ i ];

						}

					} else {

						pl.p = new Array( 1 );

					}

					pl.p[ pl.lit - 1 ] = im;

				} else if ( l ) {

					let plOffset = 0;

					for ( let i = 1 &lt;&lt; ( HUF_DECBITS - l ); i > 0; i -- ) {

						const pl = hdecod[ ( c &lt;&lt; ( HUF_DECBITS - l ) ) + plOffset ];

						if ( pl.len || pl.p ) {

							throw new Error( 'Invalid table entry' );

						}

						pl.len = l;
						pl.lit = im;

						plOffset ++;

					}

				}

			}

			return true;

		}

		const getCharReturn = { c: 0, lc: 0 };

		function getChar( c, lc, uInt8Array, inOffset ) {

			c = ( c &lt;&lt; 8 ) | parseUint8Array( uInt8Array, inOffset );
			lc += 8;

			getCharReturn.c = c;
			getCharReturn.lc = lc;

		}

		const getCodeReturn = { c: 0, lc: 0 };

		function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {

			if ( po == rlc ) {

				if ( lc &lt; 8 ) {

					getChar( c, lc, uInt8Array, inOffset );
					c = getCharReturn.c;
					lc = getCharReturn.lc;

				}

				lc -= 8;

				let cs = ( c >> lc );
				cs = new Uint8Array( [ cs ] )[ 0 ];

				if ( outBufferOffset.value + cs > outBufferEndOffset ) {

					return false;

				}

				const s = outBuffer[ outBufferOffset.value - 1 ];

				while ( cs -- > 0 ) {

					outBuffer[ outBufferOffset.value ++ ] = s;

				}

			} else if ( outBufferOffset.value &lt; outBufferEndOffset ) {

				outBuffer[ outBufferOffset.value ++ ] = po;

			} else {

				return false;

			}

			getCodeReturn.c = c;
			getCodeReturn.lc = lc;

		}

		function UInt16( value ) {

			return ( value &amp; 0xFFFF );

		}

		function Int16( value ) {

			const ref = UInt16( value );
			return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;

		}

		const wdec14Return = { a: 0, b: 0 };

		function wdec14( l, h ) {

			const ls = Int16( l );
			const hs = Int16( h );

			const hi = hs;
			const ai = ls + ( hi &amp; 1 ) + ( hi >> 1 );

			const as = ai;
			const bs = ai - hi;

			wdec14Return.a = as;
			wdec14Return.b = bs;

		}

		function wdec16( l, h ) {

			const m = UInt16( l );
			const d = UInt16( h );

			const bb = ( m - ( d >> 1 ) ) &amp; MOD_MASK;
			const aa = ( d + bb - A_OFFSET ) &amp; MOD_MASK;

			wdec14Return.a = aa;
			wdec14Return.b = bb;

		}

		function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {

			const w14 = mx &lt; ( 1 &lt;&lt; 14 );
			const n = ( nx > ny ) ? ny : nx;
			let p = 1;
			let p2;
			let py;

			while ( p &lt;= n ) p &lt;&lt;= 1;

			p >>= 1;
			p2 = p;
			p >>= 1;

			while ( p >= 1 ) {

				py = 0;
				const ey = py + oy * ( ny - p2 );
				const oy1 = oy * p;
				const oy2 = oy * p2;
				const ox1 = ox * p;
				const ox2 = ox * p2;
				let i00, i01, i10, i11;

				for ( ; py &lt;= ey; py += oy2 ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px &lt;= ex; px += ox2 ) {

						const p01 = px + ox1;
						const p10 = px + oy1;
						const p11 = p10 + ox1;

						if ( w14 ) {

							wdec14( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec14( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec14( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;

						} else {

							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec16( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec16( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;


						}

					}

					if ( nx &amp; p ) {

						const p10 = px + oy1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p10 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

						i00 = wdec14Return.a;
						buffer[ p10 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				if ( ny &amp; p ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px &lt;= ex; px += ox2 ) {

						const p01 = px + ox1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p01 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p01 + j ] );

						i00 = wdec14Return.a;
						buffer[ p01 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				p2 = p;
				p >>= 1;

			}

			return py;

		}

		function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {

			let c = 0;
			let lc = 0;
			const outBufferEndOffset = no;
			const inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );

			while ( inOffset.value &lt; inOffsetEnd ) {

				getChar( c, lc, uInt8Array, inOffset );

				c = getCharReturn.c;
				lc = getCharReturn.lc;

				while ( lc >= HUF_DECBITS ) {

					const index = ( c >> ( lc - HUF_DECBITS ) ) &amp; HUF_DECMASK;
					const pl = decodingTable[ index ];

					if ( pl.len ) {

						lc -= pl.len;

						getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

						c = getCodeReturn.c;
						lc = getCodeReturn.lc;

					} else {

						if ( ! pl.p ) {

							throw new Error( 'hufDecode issues' );

						}

						let j;

						for ( j = 0; j &lt; pl.lit; j ++ ) {

							const l = hufLength( encodingTable[ pl.p[ j ] ] );

							while ( lc &lt; l &amp;&amp; inOffset.value &lt; inOffsetEnd ) {

								getChar( c, lc, uInt8Array, inOffset );

								c = getCharReturn.c;
								lc = getCharReturn.lc;

							}

							if ( lc >= l ) {

								if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) &amp; ( ( 1 &lt;&lt; l ) - 1 ) ) ) {

									lc -= l;

									getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

									c = getCodeReturn.c;
									lc = getCodeReturn.lc;

									break;

								}

							}

						}

						if ( j == pl.lit ) {

							throw new Error( 'hufDecode issues' );

						}

					}

				}

			}

			const i = ( 8 - ni ) &amp; 7;

			c >>= i;
			lc -= i;

			while ( lc > 0 ) {

				const pl = decodingTable[ ( c &lt;&lt; ( HUF_DECBITS - lc ) ) &amp; HUF_DECMASK ];

				if ( pl.len ) {

					lc -= pl.len;

					getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

					c = getCodeReturn.c;
					lc = getCodeReturn.lc;

				} else {

					throw new Error( 'hufDecode issues' );

				}

			}

			return true;

		}

		function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {

			const outOffset = { value: 0 };
			const initialInOffset = inOffset.value;

			const im = parseUint32( inDataView, inOffset );
			const iM = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			const nBits = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			if ( im &lt; 0 || im >= HUF_ENCSIZE || iM &lt; 0 || iM >= HUF_ENCSIZE ) {

				throw new Error( 'Something wrong with HUF_ENCSIZE' );

			}

			const freq = new Array( HUF_ENCSIZE );
			const hdec = new Array( HUF_DECSIZE );

			hufClearDecTable( hdec );

			const ni = nCompressed - ( inOffset.value - initialInOffset );

			hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );

			if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {

				throw new Error( 'Something wrong with hufUncompress' );

			}

			hufBuildDecTable( freq, im, iM, hdec );

			hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );

		}

		function applyLut( lut, data, nData ) {

			for ( let i = 0; i &lt; nData; ++ i ) {

				data[ i ] = lut[ data[ i ] ];

			}

		}

		function predictor( source ) {

			for ( let t = 1; t &lt; source.length; t ++ ) {

				const d = source[ t - 1 ] + source[ t ] - 128;
				source[ t ] = d;

			}

		}

		function interleaveScalar( source, out ) {

			let t1 = 0;
			let t2 = Math.floor( ( source.length + 1 ) / 2 );
			let s = 0;
			const stop = source.length - 1;

			while ( true ) {

				if ( s > stop ) break;
				out[ s ++ ] = source[ t1 ++ ];

				if ( s > stop ) break;
				out[ s ++ ] = source[ t2 ++ ];

			}

		}

		function decodeRunLength( source ) {

			let size = source.byteLength;
			const out = new Array();
			let p = 0;

			const reader = new DataView( source );

			while ( size > 0 ) {

				const l = reader.getInt8( p ++ );

				if ( l &lt; 0 ) {

					const count = - l;
					size -= count + 1;

					for ( let i = 0; i &lt; count; i ++ ) {

						out.push( reader.getUint8( p ++ ) );

					}


				} else {

					const count = l;
					size -= 2;

					const value = reader.getUint8( p ++ );

					for ( let i = 0; i &lt; count + 1; i ++ ) {

						out.push( value );

					}

				}

			}

			return out;

		}

		function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {

			let dataView = new DataView( outBuffer.buffer );

			const width = channelData[ cscSet.idx[ 0 ] ].width;
			const height = channelData[ cscSet.idx[ 0 ] ].height;

			const numComp = 3;

			const numFullBlocksX = Math.floor( width / 8.0 );
			const numBlocksX = Math.ceil( width / 8.0 );
			const numBlocksY = Math.ceil( height / 8.0 );
			const leftoverX = width - ( numBlocksX - 1 ) * 8;
			const leftoverY = height - ( numBlocksY - 1 ) * 8;

			const currAcComp = { value: 0 };
			const currDcComp = new Array( numComp );
			const dctData = new Array( numComp );
			const halfZigBlock = new Array( numComp );
			const rowBlock = new Array( numComp );
			const rowOffsets = new Array( numComp );

			for ( let comp = 0; comp &lt; numComp; ++ comp ) {

				rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];
				currDcComp[ comp ] = ( comp &lt; 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;
				dctData[ comp ] = new Float32Array( 64 );
				halfZigBlock[ comp ] = new Uint16Array( 64 );
				rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );

			}

			for ( let blocky = 0; blocky &lt; numBlocksY; ++ blocky ) {

				let maxY = 8;

				if ( blocky == numBlocksY - 1 )
					maxY = leftoverY;

				let maxX = 8;

				for ( let blockx = 0; blockx &lt; numBlocksX; ++ blockx ) {

					if ( blockx == numBlocksX - 1 )
						maxX = leftoverX;

					for ( let comp = 0; comp &lt; numComp; ++ comp ) {

						halfZigBlock[ comp ].fill( 0 );

						// set block DC component
						halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];
						// set block AC components
						unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );

						// UnZigZag block to float
						unZigZag( halfZigBlock[ comp ], dctData[ comp ] );
						// decode float dct
						dctInverse( dctData[ comp ] );

					}

					if ( numComp == 3 ) {

						csc709Inverse( dctData );

					}

					for ( let comp = 0; comp &lt; numComp; ++ comp ) {

						convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );

					}

				} // blockx

				let offset = 0;

				for ( let comp = 0; comp &lt; numComp; ++ comp ) {

					const type = channelData[ cscSet.idx[ comp ] ].type;

					for ( let y = 8 * blocky; y &lt; 8 * blocky + maxY; ++ y ) {

						offset = rowOffsets[ comp ][ y ];

						for ( let blockx = 0; blockx &lt; numFullBlocksX; ++ blockx ) {

							const src = blockx * 64 + ( ( y &amp; 0x7 ) * 8 );

							dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );
							dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );
							dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );
							dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );

							dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );
							dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );
							dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );
							dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );

							offset += 8 * INT16_SIZE * type;

						}

					}

					// handle partial X blocks
					if ( numFullBlocksX != numBlocksX ) {

						for ( let y = 8 * blocky; y &lt; 8 * blocky + maxY; ++ y ) {

							const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;
							const src = numFullBlocksX * 64 + ( ( y &amp; 0x7 ) * 8 );

							for ( let x = 0; x &lt; maxX; ++ x ) {

								dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );

							}

						}

					}

				} // comp

			} // blocky

			const halfRow = new Uint16Array( width );
			dataView = new DataView( outBuffer.buffer );

			// convert channels back to float, if needed
			for ( let comp = 0; comp &lt; numComp; ++ comp ) {

				channelData[ cscSet.idx[ comp ] ].decoded = true;
				const type = channelData[ cscSet.idx[ comp ] ].type;

				if ( channelData[ comp ].type != 2 ) continue;

				for ( let y = 0; y &lt; height; ++ y ) {

					const offset = rowOffsets[ comp ][ y ];

					for ( let x = 0; x &lt; width; ++ x ) {

						halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );

					}

					for ( let x = 0; x &lt; width; ++ x ) {

						dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );

					}

				}

			}

		}

		function unRleAC( currAcComp, acBuffer, halfZigBlock ) {

			let acValue;
			let dctComp = 1;

			while ( dctComp &lt; 64 ) {

				acValue = acBuffer[ currAcComp.value ];

				if ( acValue == 0xff00 ) {

					dctComp = 64;

				} else if ( acValue >> 8 == 0xff ) {

					dctComp += acValue &amp; 0xff;

				} else {

					halfZigBlock[ dctComp ] = acValue;
					dctComp ++;

				}

				currAcComp.value ++;

			}

		}

		function unZigZag( src, dst ) {

			dst[ 0 ] = decodeFloat16( src[ 0 ] );
			dst[ 1 ] = decodeFloat16( src[ 1 ] );
			dst[ 2 ] = decodeFloat16( src[ 5 ] );
			dst[ 3 ] = decodeFloat16( src[ 6 ] );
			dst[ 4 ] = decodeFloat16( src[ 14 ] );
			dst[ 5 ] = decodeFloat16( src[ 15 ] );
			dst[ 6 ] = decodeFloat16( src[ 27 ] );
			dst[ 7 ] = decodeFloat16( src[ 28 ] );
			dst[ 8 ] = decodeFloat16( src[ 2 ] );
			dst[ 9 ] = decodeFloat16( src[ 4 ] );

			dst[ 10 ] = decodeFloat16( src[ 7 ] );
			dst[ 11 ] = decodeFloat16( src[ 13 ] );
			dst[ 12 ] = decodeFloat16( src[ 16 ] );
			dst[ 13 ] = decodeFloat16( src[ 26 ] );
			dst[ 14 ] = decodeFloat16( src[ 29 ] );
			dst[ 15 ] = decodeFloat16( src[ 42 ] );
			dst[ 16 ] = decodeFloat16( src[ 3 ] );
			dst[ 17 ] = decodeFloat16( src[ 8 ] );
			dst[ 18 ] = decodeFloat16( src[ 12 ] );
			dst[ 19 ] = decodeFloat16( src[ 17 ] );

			dst[ 20 ] = decodeFloat16( src[ 25 ] );
			dst[ 21 ] = decodeFloat16( src[ 30 ] );
			dst[ 22 ] = decodeFloat16( src[ 41 ] );
			dst[ 23 ] = decodeFloat16( src[ 43 ] );
			dst[ 24 ] = decodeFloat16( src[ 9 ] );
			dst[ 25 ] = decodeFloat16( src[ 11 ] );
			dst[ 26 ] = decodeFloat16( src[ 18 ] );
			dst[ 27 ] = decodeFloat16( src[ 24 ] );
			dst[ 28 ] = decodeFloat16( src[ 31 ] );
			dst[ 29 ] = decodeFloat16( src[ 40 ] );

			dst[ 30 ] = decodeFloat16( src[ 44 ] );
			dst[ 31 ] = decodeFloat16( src[ 53 ] );
			dst[ 32 ] = decodeFloat16( src[ 10 ] );
			dst[ 33 ] = decodeFloat16( src[ 19 ] );
			dst[ 34 ] = decodeFloat16( src[ 23 ] );
			dst[ 35 ] = decodeFloat16( src[ 32 ] );
			dst[ 36 ] = decodeFloat16( src[ 39 ] );
			dst[ 37 ] = decodeFloat16( src[ 45 ] );
			dst[ 38 ] = decodeFloat16( src[ 52 ] );
			dst[ 39 ] = decodeFloat16( src[ 54 ] );

			dst[ 40 ] = decodeFloat16( src[ 20 ] );
			dst[ 41 ] = decodeFloat16( src[ 22 ] );
			dst[ 42 ] = decodeFloat16( src[ 33 ] );
			dst[ 43 ] = decodeFloat16( src[ 38 ] );
			dst[ 44 ] = decodeFloat16( src[ 46 ] );
			dst[ 45 ] = decodeFloat16( src[ 51 ] );
			dst[ 46 ] = decodeFloat16( src[ 55 ] );
			dst[ 47 ] = decodeFloat16( src[ 60 ] );
			dst[ 48 ] = decodeFloat16( src[ 21 ] );
			dst[ 49 ] = decodeFloat16( src[ 34 ] );

			dst[ 50 ] = decodeFloat16( src[ 37 ] );
			dst[ 51 ] = decodeFloat16( src[ 47 ] );
			dst[ 52 ] = decodeFloat16( src[ 50 ] );
			dst[ 53 ] = decodeFloat16( src[ 56 ] );
			dst[ 54 ] = decodeFloat16( src[ 59 ] );
			dst[ 55 ] = decodeFloat16( src[ 61 ] );
			dst[ 56 ] = decodeFloat16( src[ 35 ] );
			dst[ 57 ] = decodeFloat16( src[ 36 ] );
			dst[ 58 ] = decodeFloat16( src[ 48 ] );
			dst[ 59 ] = decodeFloat16( src[ 49 ] );

			dst[ 60 ] = decodeFloat16( src[ 57 ] );
			dst[ 61 ] = decodeFloat16( src[ 58 ] );
			dst[ 62 ] = decodeFloat16( src[ 62 ] );
			dst[ 63 ] = decodeFloat16( src[ 63 ] );

		}

		function dctInverse( data ) {

			const a = 0.5 * Math.cos( 3.14159 / 4.0 );
			const b = 0.5 * Math.cos( 3.14159 / 16.0 );
			const c = 0.5 * Math.cos( 3.14159 / 8.0 );
			const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );
			const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );
			const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );
			const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );

			const alpha = new Array( 4 );
			const beta = new Array( 4 );
			const theta = new Array( 4 );
			const gamma = new Array( 4 );

			for ( let row = 0; row &lt; 8; ++ row ) {

				const rowPtr = row * 8;

				alpha[ 0 ] = c * data[ rowPtr + 2 ];
				alpha[ 1 ] = f * data[ rowPtr + 2 ];
				alpha[ 2 ] = c * data[ rowPtr + 6 ];
				alpha[ 3 ] = f * data[ rowPtr + 6 ];

				beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];
				beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];
				beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];
				beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];

				theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );
				theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );
				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];
				data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];
				data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];
				data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];

				data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];
				data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];
				data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];
				data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];

			}

			for ( let column = 0; column &lt; 8; ++ column ) {

				alpha[ 0 ] = c * data[ 16 + column ];
				alpha[ 1 ] = f * data[ 16 + column ];
				alpha[ 2 ] = c * data[ 48 + column ];
				alpha[ 3 ] = f * data[ 48 + column ];

				beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];
				beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];
				beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];
				beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];

				theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );
				theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );

				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];
				data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];
				data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];
				data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];

				data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];
				data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];
				data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];
				data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];

			}

		}

		function csc709Inverse( data ) {

			for ( let i = 0; i &lt; 64; ++ i ) {

				const y = data[ 0 ][ i ];
				const cb = data[ 1 ][ i ];
				const cr = data[ 2 ][ i ];

				data[ 0 ][ i ] = y + 1.5747 * cr;
				data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;
				data[ 2 ][ i ] = y + 1.8556 * cb;

			}

		}

		function convertToHalf( src, dst, idx ) {

			for ( let i = 0; i &lt; 64; ++ i ) {

				dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );

			}

		}

		function toLinear( float ) {

			if ( float &lt;= 1 ) {

				return Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );

			} else {

				return Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );

			}

		}

		function uncompressRAW( info ) {

			return new DataView( info.array.buffer, info.offset.value, info.size );

		}

		function uncompressRLE( info ) {

			const compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = new Uint8Array( decodeRunLength( compressed ) );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressZIP( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			if ( typeof fflate === 'undefined' ) {

				console.error( 'THREE.EXRLoader: External library fflate.min.js required.' );

			}

			const rawBuffer = fflate.unzlibSync( compressed ); // eslint-disable-line no-undef
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPIZ( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };

			const outBuffer = new Uint16Array( info.width * info.scanlineBlockSize * ( info.channels * info.type ) );
			const bitmap = new Uint8Array( BITMAP_SIZE );

			// Setup channel info
			let outBufferEnd = 0;
			const pizChannelData = new Array( info.channels );
			for ( let i = 0; i &lt; info.channels; i ++ ) {

				pizChannelData[ i ] = {};
				pizChannelData[ i ][ 'start' ] = outBufferEnd;
				pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];
				pizChannelData[ i ][ 'nx' ] = info.width;
				pizChannelData[ i ][ 'ny' ] = info.lines;
				pizChannelData[ i ][ 'size' ] = info.type;

				outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;

			}

			// Read range compression data

			const minNonZero = parseUint16( inDataView, inOffset );
			const maxNonZero = parseUint16( inDataView, inOffset );

			if ( maxNonZero >= BITMAP_SIZE ) {

				throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );

			}

			if ( minNonZero &lt;= maxNonZero ) {

				for ( let i = 0; i &lt; maxNonZero - minNonZero + 1; i ++ ) {

					bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );

				}

			}

			// Reverse LUT
			const lut = new Uint16Array( USHORT_RANGE );
			const maxValue = reverseLutFromBitmap( bitmap, lut );

			const length = parseUint32( inDataView, inOffset );

			// Huffman decoding
			hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );

			// Wavelet decoding
			for ( let i = 0; i &lt; info.channels; ++ i ) {

				const cd = pizChannelData[ i ];

				for ( let j = 0; j &lt; pizChannelData[ i ].size; ++ j ) {

					wav2Decode(
						outBuffer,
						cd.start + j,
						cd.nx,
						cd.size,
						cd.ny,
						cd.nx * cd.size,
						maxValue
					);

				}

			}

			// Expand the pixel data to their original range
			applyLut( lut, outBuffer, outBufferEnd );

			// Rearrange the pixel data into the format expected by the caller.
			let tmpOffset = 0;
			const tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );
			for ( let y = 0; y &lt; info.lines; y ++ ) {

				for ( let c = 0; c &lt; info.channels; c ++ ) {

					const cd = pizChannelData[ c ];

					const n = cd.nx * cd.size;
					const cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );

					tmpBuffer.set( cp, tmpOffset );
					tmpOffset += n * INT16_SIZE;
					cd.end += n;

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPXR( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			if ( typeof fflate === 'undefined' ) {

				console.error( 'THREE.EXRLoader: External library fflate.min.js required.' );

			}

			const rawBuffer = fflate.unzlibSync( compressed ); // eslint-disable-line no-undef

			const sz = info.lines * info.channels * info.width;
			const tmpBuffer = ( info.type == 1 ) ? new Uint16Array( sz ) : new Uint32Array( sz );

			let tmpBufferEnd = 0;
			let writePtr = 0;
			const ptr = new Array( 4 );

			for ( let y = 0; y &lt; info.lines; y ++ ) {

				for ( let c = 0; c &lt; info.channels; c ++ ) {

					let pixel = 0;

					switch ( info.type ) {

						case 1:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.width;
							tmpBufferEnd = ptr[ 1 ] + info.width;

							for ( let j = 0; j &lt; info.width; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] &lt;&lt; 8 ) | rawBuffer[ ptr[ 1 ] ++ ];

								pixel += diff;

								tmpBuffer[ writePtr ] = pixel;
								writePtr ++;

							}

							break;

						case 2:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.width;
							ptr[ 2 ] = ptr[ 1 ] + info.width;
							tmpBufferEnd = ptr[ 2 ] + info.width;

							for ( let j = 0; j &lt; info.width; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] &lt;&lt; 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] &lt;&lt; 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] &lt;&lt; 8 );

								pixel += diff;

								tmpBuffer[ writePtr ] = pixel;
								writePtr ++;

							}

							break;

					}

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressDWA( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };
			const outBuffer = new Uint8Array( info.width * info.lines * ( info.channels * info.type * INT16_SIZE ) );

			// Read compression header information
			const dwaHeader = {

				version: parseInt64( inDataView, inOffset ),
				unknownUncompressedSize: parseInt64( inDataView, inOffset ),
				unknownCompressedSize: parseInt64( inDataView, inOffset ),
				acCompressedSize: parseInt64( inDataView, inOffset ),
				dcCompressedSize: parseInt64( inDataView, inOffset ),
				rleCompressedSize: parseInt64( inDataView, inOffset ),
				rleUncompressedSize: parseInt64( inDataView, inOffset ),
				rleRawSize: parseInt64( inDataView, inOffset ),
				totalAcUncompressedCount: parseInt64( inDataView, inOffset ),
				totalDcUncompressedCount: parseInt64( inDataView, inOffset ),
				acCompression: parseInt64( inDataView, inOffset )

			};

			if ( dwaHeader.version &lt; 2 )
				throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );

			// Read channel ruleset information
			const channelRules = new Array();
			let ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;

			while ( ruleSize > 0 ) {

				const name = parseNullTerminatedString( inDataView.buffer, inOffset );
				const value = parseUint8( inDataView, inOffset );
				const compression = ( value >> 2 ) &amp; 3;
				const csc = ( value >> 4 ) - 1;
				const index = new Int8Array( [ csc ] )[ 0 ];
				const type = parseUint8( inDataView, inOffset );

				channelRules.push( {
					name: name,
					index: index,
					type: type,
					compression: compression,
				} );

				ruleSize -= name.length + 3;

			}

			// Classify channels
			const channels = EXRHeader.channels;
			const channelData = new Array( info.channels );

			for ( let i = 0; i &lt; info.channels; ++ i ) {

				const cd = channelData[ i ] = {};
				const channel = channels[ i ];

				cd.name = channel.name;
				cd.compression = UNKNOWN;
				cd.decoded = false;
				cd.type = channel.pixelType;
				cd.pLinear = channel.pLinear;
				cd.width = info.width;
				cd.height = info.lines;

			}

			const cscSet = {
				idx: new Array( 3 )
			};

			for ( let offset = 0; offset &lt; info.channels; ++ offset ) {

				const cd = channelData[ offset ];

				for ( let i = 0; i &lt; channelRules.length; ++ i ) {

					const rule = channelRules[ i ];

					if ( cd.name == rule.name ) {

						cd.compression = rule.compression;

						if ( rule.index >= 0 ) {

							cscSet.idx[ rule.index ] = offset;

						}

						cd.offset = offset;

					}

				}

			}

			let acBuffer, dcBuffer, rleBuffer;

			// Read DCT - AC component data
			if ( dwaHeader.acCompressedSize > 0 ) {

				switch ( dwaHeader.acCompression ) {

					case STATIC_HUFFMAN:

						acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );
						hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );
						break;

					case DEFLATE:

						const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );
						const data = fflate.unzlibSync( compressed ); // eslint-disable-line no-undef
						acBuffer = new Uint16Array( data.buffer );
						inOffset.value += dwaHeader.totalAcUncompressedCount;
						break;

				}


			}

			// Read DCT - DC component data
			if ( dwaHeader.dcCompressedSize > 0 ) {

				const zlibInfo = {
					array: info.array,
					offset: inOffset,
					size: dwaHeader.dcCompressedSize
				};
				dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );
				inOffset.value += dwaHeader.dcCompressedSize;

			}

			// Read RLE compressed data
			if ( dwaHeader.rleRawSize > 0 ) {

				const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );
				const data = fflate.unzlibSync( compressed ); // eslint-disable-line no-undef
				rleBuffer = decodeRunLength( data.buffer );

				inOffset.value += dwaHeader.rleCompressedSize;

			}

			// Prepare outbuffer data offset
			let outBufferEnd = 0;
			const rowOffsets = new Array( channelData.length );
			for ( let i = 0; i &lt; rowOffsets.length; ++ i ) {

				rowOffsets[ i ] = new Array();

			}

			for ( let y = 0; y &lt; info.lines; ++ y ) {

				for ( let chan = 0; chan &lt; channelData.length; ++ chan ) {

					rowOffsets[ chan ].push( outBufferEnd );
					outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;

				}

			}

			// Lossy DCT decode RGB channels
			lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );

			// Decode other channels
			for ( let i = 0; i &lt; channelData.length; ++ i ) {

				const cd = channelData[ i ];

				if ( cd.decoded ) continue;

				switch ( cd.compression ) {

					case RLE:

						let row = 0;
						let rleOffset = 0;

						for ( let y = 0; y &lt; info.lines; ++ y ) {

							let rowOffsetBytes = rowOffsets[ i ][ row ];

							for ( let x = 0; x &lt; cd.width; ++ x ) {

								for ( let byte = 0; byte &lt; INT16_SIZE * cd.type; ++ byte ) {

									outBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];

								}

								rleOffset ++;

							}

							row ++;

						}

						break;

					case LOSSY_DCT: // skip

					default:
						throw new Error( 'EXRLoader.parse: unsupported channel compression' );

				}

			}

			return new DataView( outBuffer.buffer );

		}

		function parseNullTerminatedString( buffer, offset ) {

			const uintBuffer = new Uint8Array( buffer );
			let endOffset = 0;

			while ( uintBuffer[ offset.value + endOffset ] != 0 ) {

				endOffset += 1;

			}

			const stringValue = new TextDecoder().decode(
				uintBuffer.slice( offset.value, offset.value + endOffset )
			);

			offset.value = offset.value + endOffset + 1;

			return stringValue;

		}

		function parseFixedLengthString( buffer, offset, size ) {

			const stringValue = new TextDecoder().decode(
				new Uint8Array( buffer ).slice( offset.value, offset.value + size )
			);

			offset.value = offset.value + size;

			return stringValue;

		}

		function parseRational( dataView, offset ) {

			const x = parseInt32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseTimecode( dataView, offset ) {

			const x = parseUint32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseInt32( dataView, offset ) {

			const Int32 = dataView.getInt32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Int32;

		}

		function parseUint32( dataView, offset ) {

			const Uint32 = dataView.getUint32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Uint32;

		}

		function parseUint8Array( uInt8Array, offset ) {

			const Uint8 = uInt8Array[ offset.value ];

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		function parseUint8( dataView, offset ) {

			const Uint8 = dataView.getUint8( offset.value );

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		const parseInt64 = function ( dataView, offset ) {

			const Int64 = Number( dataView.getBigInt64( offset.value, true ) );

			offset.value += ULONG_SIZE;

			return Int64;

		};

		function parseFloat32( dataView, offset ) {

			const float = dataView.getFloat32( offset.value, true );

			offset.value += FLOAT32_SIZE;

			return float;

		}

		function decodeFloat32( dataView, offset ) {

			return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );

		}

		// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
		function decodeFloat16( binary ) {

			const exponent = ( binary &amp; 0x7C00 ) >> 10,
				fraction = binary &amp; 0x03FF;

			return ( binary >> 15 ? - 1 : 1 ) * (
				exponent ?
					(
						exponent === 0x1F ?
							fraction ? NaN : Infinity :
							Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )
					) :
					6.103515625e-5 * ( fraction / 0x400 )
			);

		}

		function parseUint16( dataView, offset ) {

			const Uint16 = dataView.getUint16( offset.value, true );

			offset.value += INT16_SIZE;

			return Uint16;

		}

		function parseFloat16( buffer, offset ) {

			return decodeFloat16( parseUint16( buffer, offset ) );

		}

		function parseChlist( dataView, buffer, offset, size ) {

			const startOffset = offset.value;
			const channels = [];

			while ( offset.value &lt; ( startOffset + size - 1 ) ) {

				const name = parseNullTerminatedString( buffer, offset );
				const pixelType = parseInt32( dataView, offset );
				const pLinear = parseUint8( dataView, offset );
				offset.value += 3; // reserved, three chars
				const xSampling = parseInt32( dataView, offset );
				const ySampling = parseInt32( dataView, offset );

				channels.push( {
					name: name,
					pixelType: pixelType,
					pLinear: pLinear,
					xSampling: xSampling,
					ySampling: ySampling
				} );

			}

			offset.value += 1;

			return channels;

		}

		function parseChromaticities( dataView, offset ) {

			const redX = parseFloat32( dataView, offset );
			const redY = parseFloat32( dataView, offset );
			const greenX = parseFloat32( dataView, offset );
			const greenY = parseFloat32( dataView, offset );
			const blueX = parseFloat32( dataView, offset );
			const blueY = parseFloat32( dataView, offset );
			const whiteX = parseFloat32( dataView, offset );
			const whiteY = parseFloat32( dataView, offset );

			return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };

		}

		function parseCompression( dataView, offset ) {

			const compressionCodes = [
				'NO_COMPRESSION',
				'RLE_COMPRESSION',
				'ZIPS_COMPRESSION',
				'ZIP_COMPRESSION',
				'PIZ_COMPRESSION',
				'PXR24_COMPRESSION',
				'B44_COMPRESSION',
				'B44A_COMPRESSION',
				'DWAA_COMPRESSION',
				'DWAB_COMPRESSION'
			];

			const compression = parseUint8( dataView, offset );

			return compressionCodes[ compression ];

		}

		function parseBox2i( dataView, offset ) {

			const xMin = parseUint32( dataView, offset );
			const yMin = parseUint32( dataView, offset );
			const xMax = parseUint32( dataView, offset );
			const yMax = parseUint32( dataView, offset );

			return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };

		}

		function parseLineOrder( dataView, offset ) {

			const lineOrders = [
				'INCREASING_Y'
			];

			const lineOrder = parseUint8( dataView, offset );

			return lineOrders[ lineOrder ];

		}

		function parseV2f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );

			return [ x, y ];

		}

		function parseV3f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );
			const z = parseFloat32( dataView, offset );

			return [ x, y, z ];

		}

		function parseValue( dataView, buffer, offset, type, size ) {

			if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {

				return parseFixedLengthString( buffer, offset, size );

			} else if ( type === 'chlist' ) {

				return parseChlist( dataView, buffer, offset, size );

			} else if ( type === 'chromaticities' ) {

				return parseChromaticities( dataView, offset );

			} else if ( type === 'compression' ) {

				return parseCompression( dataView, offset );

			} else if ( type === 'box2i' ) {

				return parseBox2i( dataView, offset );

			} else if ( type === 'lineOrder' ) {

				return parseLineOrder( dataView, offset );

			} else if ( type === 'float' ) {

				return parseFloat32( dataView, offset );

			} else if ( type === 'v2f' ) {

				return parseV2f( dataView, offset );

			} else if ( type === 'v3f' ) {

				return parseV3f( dataView, offset );

			} else if ( type === 'int' ) {

				return parseInt32( dataView, offset );

			} else if ( type === 'rational' ) {

				return parseRational( dataView, offset );

			} else if ( type === 'timecode' ) {

				return parseTimecode( dataView, offset );

			} else if ( type === 'preview' ) {

				offset.value += size;
				return 'skipped';

			} else {

				offset.value += size;
				return undefined;

			}

		}

		function parseHeader( dataView, buffer, offset ) {

			const EXRHeader = {};

			if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic

				throw new Error( 'THREE.EXRLoader: provided file doesn\'t appear to be in OpenEXR format.' );

			}

			EXRHeader.version = dataView.getUint8( 4 );

			const spec = dataView.getUint8( 5 ); // fullMask

			EXRHeader.spec = {
				singleTile: !! ( spec &amp; 2 ),
				longName: !! ( spec &amp; 4 ),
				deepFormat: !! ( spec &amp; 8 ),
				multiPart: !! ( spec &amp; 16 ),
			};

			// start of header

			offset.value = 8; // start at 8 - after pre-amble

			let keepReading = true;

			while ( keepReading ) {

				const attributeName = parseNullTerminatedString( buffer, offset );

				if ( attributeName == 0 ) {

					keepReading = false;

				} else {

					const attributeType = parseNullTerminatedString( buffer, offset );
					const attributeSize = parseUint32( dataView, offset );
					const attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );

					if ( attributeValue === undefined ) {

						console.warn( `EXRLoader.parse: skipped unknown header attribute type \'${attributeType}\'.` );

					} else {

						EXRHeader[ attributeName ] = attributeValue;

					}

				}

			}

			if ( ( spec &amp; ~ 0x04 ) != 0 ) { // unsupported tiled, deep-image, multi-part

				console.error( 'EXRHeader:', EXRHeader );
				throw new Error( 'THREE.EXRLoader: provided file is currently unsupported.' );

			}

			return EXRHeader;

		}

		function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {

			const EXRDecoder = {
				size: 0,
				viewer: dataView,
				array: uInt8Array,
				offset: offset,
				width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,
				height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,
				channels: EXRHeader.channels.length,
				bytesPerLine: null,
				lines: null,
				inputSize: null,
				type: EXRHeader.channels[ 0 ].pixelType,
				uncompress: null,
				getter: null,
				format: null,
				encoding: null,
			};

			switch ( EXRHeader.compression ) {

				case 'NO_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressRAW;
					break;

				case 'RLE_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressRLE;
					break;

				case 'ZIPS_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'ZIP_COMPRESSION':
					EXRDecoder.lines = 16;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'PIZ_COMPRESSION':
					EXRDecoder.lines = 32;
					EXRDecoder.uncompress = uncompressPIZ;
					break;

				case 'PXR24_COMPRESSION':
					EXRDecoder.lines = 16;
					EXRDecoder.uncompress = uncompressPXR;
					break;

				case 'DWAA_COMPRESSION':
					EXRDecoder.lines = 32;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				case 'DWAB_COMPRESSION':
					EXRDecoder.lines = 256;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				default:
					throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );

			}

			EXRDecoder.scanlineBlockSize = EXRDecoder.lines;

			if ( EXRDecoder.type == 1 ) {

				// half
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat16;
						EXRDecoder.inputSize = INT16_SIZE;
						break;

					case HalfFloatType:
						EXRDecoder.getter = parseUint16;
						EXRDecoder.inputSize = INT16_SIZE;
						break;

				}

			} else if ( EXRDecoder.type == 2 ) {

				// float
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat32;
						EXRDecoder.inputSize = FLOAT32_SIZE;
						break;

					case HalfFloatType:
						EXRDecoder.getter = decodeFloat32;
						EXRDecoder.inputSize = FLOAT32_SIZE;

				}

			} else {

				throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );

			}

			EXRDecoder.blockCount = ( EXRHeader.dataWindow.yMax + 1 ) / EXRDecoder.scanlineBlockSize;

			for ( let i = 0; i &lt; EXRDecoder.blockCount; i ++ )
				parseInt64( dataView, offset ); // scanlineOffset

			// we should be passed the scanline offset table, ready to start reading pixel data.

			// RGB images will be converted to RGBA format, preventing software emulation in select devices.
			EXRDecoder.outputChannels = ( ( EXRDecoder.channels == 3 ) ? 4 : EXRDecoder.channels );
			const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;

			switch ( outputType ) {

				case FloatType:
					EXRDecoder.byteArray = new Float32Array( size );

					// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
					if ( EXRDecoder.channels &lt; EXRDecoder.outputChannels )
						EXRDecoder.byteArray.fill( 1, 0, size );

					break;

				case HalfFloatType:
					EXRDecoder.byteArray = new Uint16Array( size );

					if ( EXRDecoder.channels &lt; EXRDecoder.outputChannels )
						EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1

					break;

				default:
					console.error( 'THREE.EXRLoader: unsupported type: ', outputType );
					break;

			}

			EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;

			if ( EXRDecoder.outputChannels == 4 ) {

				EXRDecoder.format = RGBAFormat;
				EXRDecoder.encoding = LinearEncoding;

			} else {

				EXRDecoder.format = RedFormat;
				EXRDecoder.encoding = LinearEncoding;

			}

			return EXRDecoder;

		}

		// start parsing file [START]

		const bufferDataView = new DataView( buffer );
		const uInt8Array = new Uint8Array( buffer );
		const offset = { value: 0 };

		// get header information and validate format.
		const EXRHeader = parseHeader( bufferDataView, buffer, offset );

		// get input compression information and prepare decoding.
		const EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );

		const tmpOffset = { value: 0 };
		const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };

		for ( let scanlineBlockIdx = 0; scanlineBlockIdx &lt; EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx ++ ) {

			const line = parseUint32( bufferDataView, offset ); // line_no
			EXRDecoder.size = parseUint32( bufferDataView, offset ); // data_len
			EXRDecoder.lines = ( ( line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.scanlineBlockSize );

			const isCompressed = EXRDecoder.size &lt; EXRDecoder.lines * EXRDecoder.bytesPerLine;
			const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

			offset.value += EXRDecoder.size;

			for ( let line_y = 0; line_y &lt; EXRDecoder.scanlineBlockSize; line_y ++ ) {

				const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
				if ( true_y >= EXRDecoder.height ) break;

				for ( let channelID = 0; channelID &lt; EXRDecoder.channels; channelID ++ ) {

					const cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];

					for ( let x = 0; x &lt; EXRDecoder.width; x ++ ) {

						tmpOffset.value = ( line_y * ( EXRDecoder.channels * EXRDecoder.width ) + channelID * EXRDecoder.width + x ) * EXRDecoder.inputSize;
						const outIndex = ( EXRDecoder.height - 1 - true_y ) * ( EXRDecoder.width * EXRDecoder.outputChannels ) + x * EXRDecoder.outputChannels + cOff;
						EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

					}

				}

			}

		}

		return {
			header: EXRHeader,
			width: EXRDecoder.width,
			height: EXRDecoder.height,
			data: EXRDecoder.byteArray,
			format: EXRDecoder.format,
			encoding: EXRDecoder.encoding,
			type: this.type,
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			texture.encoding = texData.encoding;
			texture.minFilter = LinearFilter;
			texture.magFilter = LinearFilter;
			texture.generateMipmaps = false;
			texture.flipY = false;

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

export { EXRLoader };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-postcss-load-config.html">postcss-load-config</a></li></ul><h3>Namespaces</h3><ul><li><a href="opentype.html">opentype</a></li></ul><h3>Classes</h3><ul><li><a href="AMFLoader.html">AMFLoader</a></li><li><a href="AdaptiveToneMappingPass.html">AdaptiveToneMappingPass</a></li><li><a href="AnimationObjectGroup.html">AnimationObjectGroup</a></li><li><a href="ArcballControls.html">ArcballControls</a></li><li><a href="AsciiEffect.html">AsciiEffect</a></li><li><a href="AudioManager.html">AudioManager</a></li><li><a href="BVHLoader.html">BVHLoader</a></li><li><a href="BokehPass.html">BokehPass</a></li><li><a href="BooleanController.html">BooleanController</a></li><li><a href="BooleanKeyframeTrack.html">BooleanKeyframeTrack</a></li><li><a href="BulkUpdateDecorator.html">BulkUpdateDecorator</a></li><li><a href="CCDIKHelper.html">CCDIKHelper</a></li><li><a href="CCDIKSolver.html">CCDIKSolver</a></li><li><a href="CameraHelper.html">CameraHelper</a></li><li><a href="Chunk.html">Chunk</a></li><li><a href="ColladaExporter.html">ColladaExporter</a></li><li><a href="ColorController.html">ColorController</a></li><li><a href="ColorKeyframeTrack.html">ColorKeyframeTrack</a></li><li><a href="Component.html">Component</a></li><li><a href="Composer.html">Composer</a></li><li><a href="CompressedTextureLoader.html">CompressedTextureLoader</a></li><li><a href="Constraint.html">Constraint</a></li><li><a href="ContentDisposition.html">ContentDisposition</a></li><li><a href="Controller.html">Controller</a></li><li><a href="CubicInterpolant.html">CubicInterpolant</a></li><li><a href="Curve.html">Curve</a></li><li><a href="Cylindrical.html">Cylindrical</a></li><li><a href="DataTextureLoader.html">DataTextureLoader</a></li><li><a href="DecalGeometry.html">DecalGeometry</a></li><li><a href="DirEntry.html">DirEntry</a></li><li><a href="DiscreteInterpolant.html">DiscreteInterpolant</a></li><li><a href="EXRLoader.html">EXRLoader</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="ExtrudeGeometry.html">ExtrudeGeometry</a></li><li><a href="FSWatcher.html">FSWatcher</a></li><li><a href="Flow.html">Flow</a></li><li><a href="FunctionController.html">FunctionController</a></li><li><a href="GCodeLoader.html">GCodeLoader</a></li><li><a href="GLTFDracoMeshCompressionExtension.html">GLTFDracoMeshCompressionExtension</a></li><li><a href="GLTFLightExtension.html">GLTFLightExtension</a></li><li><a href="GLTFLightsExtension.html">GLTFLightsExtension</a></li><li><a href="GLTFMaterialsClearcoatExtension.html">GLTFMaterialsClearcoatExtension</a></li><li><a href="GLTFMaterialsEmissiveStrengthExtension.html">GLTFMaterialsEmissiveStrengthExtension</a></li><li><a href="GLTFMaterialsIorExtension.html">GLTFMaterialsIorExtension</a></li><li><a href="GLTFMaterialsIridescenceExtension.html">GLTFMaterialsIridescenceExtension</a></li><li><a href="GLTFMaterialsPBRSpecularGlossiness.html">GLTFMaterialsPBRSpecularGlossiness</a></li><li><a href="GLTFMaterialsSheenExtension.html">GLTFMaterialsSheenExtension</a></li><li><a href="GLTFMaterialsSpecularExtension.html">GLTFMaterialsSpecularExtension</a></li><li><a href="GLTFMaterialsTransmissionExtension.html">GLTFMaterialsTransmissionExtension</a></li><li><a href="GLTFMaterialsUnlitExtension.html">GLTFMaterialsUnlitExtension</a></li><li><a href="GLTFMaterialsVolumeExtension.html">GLTFMaterialsVolumeExtension</a></li><li><a href="GLTFMeshQuantizationExtension.html">GLTFMeshQuantizationExtension</a></li><li><a href="GLTFMeshStandardSGMaterial.html">GLTFMeshStandardSGMaterial</a></li><li><a href="GLTFMeshoptCompression.html">GLTFMeshoptCompression</a></li><li><a href="GLTFTextureBasisUExtension.html">GLTFTextureBasisUExtension</a></li><li><a href="GLTFTextureTransformExtension.html">GLTFTextureTransformExtension</a></li><li><a href="GLTFTextureWebPExtension.html">GLTFTextureWebPExtension</a></li><li><a href="GLTFWriter.html">GLTFWriter</a></li><li><a href="GPUComputationRenderer.html">GPUComputationRenderer</a></li><li><a href="GUI.html">GUI</a></li><li><a href="GenMapping.html">GenMapping</a></li><li><a href="GrannyKnot.html">GrannyKnot</a></li><li><a href="GrantSolver.html">GrantSolver</a></li><li><a href="GroundProjectedEnv.html">GroundProjectedEnv</a></li><li><a href="HalftonePass.html">HalftonePass</a></li><li><a href="InstancedFlow.html">InstancedFlow</a></li><li><a href="Interpolant.html">Interpolant</a></li><li><a href="KTXLoader.html">KTXLoader</a></li><li><a href="KhronosTextureContainer.html">KhronosTextureContainer</a></li><li><a href="Lexer.html">Lexer</a></li><li><a href="LineCounter.html">LineCounter</a></li><li><a href="MDDLoader.html">MDDLoader</a></li><li><a href="MMDAnimationHelper.html">MMDAnimationHelper</a></li><li><a href="MMDExporter.html">MMDExporter</a></li><li><a href="MMDLoader.html">MMDLoader</a></li><li><a href="MMDPhysics.html">MMDPhysics</a></li><li><a href="MMDPhysicsHelper.html">MMDPhysicsHelper</a></li><li><a href="MTLLoader.html">MTLLoader</a></li><li><a href="MarchingCubes.html">MarchingCubes</a></li><li><a href="MaterialBuilder.html">MaterialBuilder</a></li><li><a href="MaterialCreator.html">MaterialCreator</a></li><li><a href="MeshBuilder.html">MeshBuilder</a></li><li><a href="MotionController.html">MotionController</a></li><li><a href="NURBSCurve.html">NURBSCurve</a></li><li><a href="NURBSSurface.html">NURBSSurface</a></li><li><a href="NumberController.html">NumberController</a></li><li><a href="NumberControllerBox.html">NumberControllerBox</a></li><li><a href="NumberControllerSlider.html">NumberControllerSlider</a></li><li><a href="NumberKeyframeTrack.html">NumberKeyframeTrack</a></li><li><a href="OptionController.html">OptionController</a></li><li><a href="OutlineEffect.html">OutlineEffect</a></li><li><a href="PLYExporter.html">PLYExporter</a></li><li><a href="PMREMGenerator.html">PMREMGenerator</a></li><li><a href="PackedPhongMaterial.html">PackedPhongMaterial</a></li><li><a href="ParametricGeometry.html">ParametricGeometry</a></li><li><a href="Parser$1.html">Parser$1</a></li><li><a href="PeppersGhostEffect.html">PeppersGhostEffect</a></li><li><a href="ProgressiveLightMap.html">ProgressiveLightMap</a></li><li><a href="QuaternionKeyframeTrack.html">QuaternionKeyframeTrack</a></li><li><a href="QuaternionLinearInterpolant.html">QuaternionLinearInterpolant</a></li><li><a href="Query.html">Query</a></li><li><a href="RectAreaLightHelper.html">RectAreaLightHelper</a></li><li><a href="RectAreaLightUniformsLib.html">RectAreaLightUniformsLib</a></li><li><a href="ResourceManager.html">ResourceManager</a></li><li><a href="RigidBody.html">RigidBody</a></li><li><a href="RoomEnvironment.html">RoomEnvironment</a></li><li><a href="SAOPass.html">SAOPass</a></li><li><a href="SSAARenderPass.html">SSAARenderPass</a></li><li><a href="STLExporter.html">STLExporter</a></li><li><a href="STLLoader.html">STLLoader</a></li><li><a href="SetArray.html">SetArray</a></li><li><a href="ShadowMapViewer.html">ShadowMapViewer</a></li><li><a href="SimplexNoise.html">SimplexNoise</a></li><li><a href="Sky.html">Sky</a></li><li><a href="SourceMap$1.html">SourceMap$1</a></li><li><a href="Spherical.html">Spherical</a></li><li><a href="SphericalHarmonics3.html">SphericalHarmonics3</a></li><li><a href="StringController.html">StringController</a></li><li><a href="StringKeyframeTrack.html">StringKeyframeTrack</a></li><li><a href="TAARenderPass.html">TAARenderPass</a></li><li><a href="TDSLoader.html">TDSLoader</a></li><li><a href="TTFLoader.html">TTFLoader</a></li><li><a href="TeapotGeometry.html">TeapotGeometry</a></li><li><a href="TessellateModifier.html">TessellateModifier</a></li><li><a href="TextGeometry.html">TextGeometry</a></li><li><a href="ThreeMFLoader.html">ThreeMFLoader</a></li><li><a href="UnrealBloomPass.html">UnrealBloomPass</a></li><li><a href="VectorKeyframeTrack.html">VectorKeyframeTrack</a></li><li><a href="VisualResponse.html">VisualResponse</a></li><li><a href="Volume.html">Volume</a></li><li><a href="VolumeSlice.html">VolumeSlice</a></li><li><a href="WasmHash.html">WasmHash</a></li><li><a href="Water.html">Water</a></li><li><a href="WorkerPool.html">WorkerPool</a></li><li><a href="module-postcss-load-config-CloseEvent.html">CloseEvent</a></li><li><a href="module-postcss-load-config-DirEntry.html">DirEntry</a></li><li><a href="module-postcss-load-config-ErrorEvent.html">ErrorEvent</a></li><li><a href="module-postcss-load-config-Event.html">Event</a></li><li><a href="module-postcss-load-config-FSWatcher.html">FSWatcher</a></li><li><a href="module-postcss-load-config-Limiter$1.html">Limiter$1</a></li><li><a href="module-postcss-load-config-MessageEvent.html">MessageEvent</a></li><li><a href="module-postcss-load-config-ModuleNode.html">ModuleNode</a></li><li><a href="module-postcss-load-config-PerMessageDeflate$4.html">PerMessageDeflate$4</a></li><li><a href="module-postcss-load-config-Receiver$1.html">Receiver$1</a></li><li><a href="module-postcss-load-config-Sender$1.html">Sender$1</a></li><li><a href="module-postcss-load-config-WebSocket$1.html">WebSocket$1</a></li><li><a href="module-postcss-load-config-WebSocketServer.html">WebSocketServer</a></li><li><a href="opentype.BoundingBox.html">BoundingBox</a></li><li><a href="opentype.CffEncoding.html">CffEncoding</a></li><li><a href="opentype.CmapEncoding.html">CmapEncoding</a></li><li><a href="opentype.Coverage.html">Coverage</a></li><li><a href="opentype.DefaultEncoding.html">DefaultEncoding</a></li><li><a href="opentype.FeatureList.html">FeatureList</a></li><li><a href="opentype.Font.html">Font</a></li><li><a href="opentype.Glyph.html">Glyph</a></li><li><a href="opentype.GlyphNames.html">GlyphNames</a></li><li><a href="opentype.GlyphSet.html">GlyphSet</a></li><li><a href="opentype.Layout.html">Layout</a></li><li><a href="opentype.LookupList.html">LookupList</a></li><li><a href="opentype.Path.html">Path</a></li><li><a href="opentype.Position.html">Position</a></li><li><a href="opentype.Substitution.html">Substitution</a></li><li><a href="opentype.Table.html">Table</a></li><li><a href="opentype.decode.html">decode</a></li><li><a href="opentype.encode.html">encode</a></li><li><a href="opentype.sizeOf.html">sizeOf</a></li><li><a href="t.html">t</a></li></ul><h3>Mixins</h3><ul><li><a href="FsEventsHandler$1.html">FsEventsHandler$1</a></li><li><a href="NodeFsHandler$1.html">NodeFsHandler$1</a></li><li><a href="module-postcss-load-config-EventTarget.html">EventTarget</a></li><li><a href="module-postcss-load-config-FsEventsHandler$1.html">FsEventsHandler$1</a></li><li><a href="module-postcss-load-config-NodeFsHandler$1.html">NodeFsHandler$1</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#ACESFilmicToneMappingShader">ACESFilmicToneMappingShader</a></li><li><a href="global.html#ARR_EACH">ARR_EACH</a></li><li><a href="global.html#Accepts">Accepts</a></li><li><a href="global.html#AfterimageShader">AfterimageShader</a></li><li><a href="global.html#ArraySet">ArraySet</a></li><li><a href="global.html#AsyncDecompress">AsyncDecompress</a></li><li><a href="global.html#AsyncDeflate">AsyncDeflate</a></li><li><a href="global.html#AsyncGunzip">AsyncGunzip</a></li><li><a href="global.html#AsyncGzip">AsyncGzip</a></li><li><a href="global.html#AsyncInflate">AsyncInflate</a></li><li><a href="global.html#AsyncUnzipInflate">AsyncUnzipInflate</a></li><li><a href="global.html#AsyncUnzlib">AsyncUnzlib</a></li><li><a href="global.html#AsyncZipDeflate">AsyncZipDeflate</a></li><li><a href="global.html#AsyncZlib">AsyncZlib</a></li><li><a href="global.html#BOM">BOM</a></li><li><a href="global.html#BasicShader">BasicShader</a></li><li><a href="global.html#BasicSourceMapConsumer">BasicSourceMapConsumer</a></li><li><a href="global.html#Bidi">Bidi</a></li><li><a href="global.html#BleachBypassShader">BleachBypassShader</a></li><li><a href="global.html#BlendShader">BlendShader</a></li><li><a href="global.html#BokehShader">BokehShader</a></li><li><a href="global.html#BrightnessContrastShader">BrightnessContrastShader</a></li><li><a href="global.html#Buffer">Buffer</a></li><li><a href="global.html#Calculatesalldynamicvalues">Calculates all dynamic values</a></li><li><a href="global.html#CatmullRom">CatmullRom</a></li><li><a href="global.html#CharCodes%255Bundefined%255D">CharCodes[undefined]</a></li><li><a href="global.html#CharsetEncoder">CharsetEncoder</a></li><li><a href="global.html#ColorCorrectionShader">ColorCorrectionShader</a></li><li><a href="global.html#ColorifyShader">ColorifyShader</a></li><li><a href="global.html#Common">Common</a></li><li><a href="global.html#Constants">Constants</a></li><li><a href="global.html#ContextChecker">ContextChecker</a></li><li><a href="global.html#ContextRange">ContextRange</a></li><li><a href="global.html#ConvolutionShader">ConvolutionShader</a></li><li><a href="global.html#CopyShader">CopyShader</a></li><li><a href="global.html#DOCUMENT">DOCUMENT</a></li><li><a href="global.html#DOCUMENT_MODE">DOCUMENT_MODE</a></li><li><a href="global.html#DOFMipMapShader">DOFMipMapShader</a></li><li><a href="global.html#DOT_LITERAL">DOT_LITERAL</a></li><li><a href="global.html#DOUBLE_SLASH_RE$1">DOUBLE_SLASH_RE$1</a></li><li><a href="global.html#DataCreationHelper">DataCreationHelper</a></li><li><a href="global.html#DataViewEx">DataViewEx</a></li><li><a href="global.html#DecodeUTF8">DecodeUTF8</a></li><li><a href="global.html#Decompress">Decompress</a></li><li><a href="global.html#Deflate">Deflate</a></li><li><a href="global.html#DeprecationError">DeprecationError</a></li><li><a href="global.html#DepthLimitedBlurShader">DepthLimitedBlurShader</a></li><li><a href="global.html#DigitalGlitch">DigitalGlitch</a></li><li><a href="global.html#DotScreenShader">DotScreenShader</a></li><li><a href="global.html#Earcut">Earcut</a></li><li><a href="global.html#EncodeUTF8">EncodeUTF8</a></li><li><a href="global.html#Event">Event</a></li><li><a href="global.html#FIELD_NAME_REGEXP">FIELD_NAME_REGEXP</a></li><li><a href="global.html#FIRST_CHAR_REGEXP">FIRST_CHAR_REGEXP</a></li><li><a href="global.html#FLOW_END">FLOW_END</a></li><li><a href="global.html#FSEventsWatchers">FSEventsWatchers</a></li><li><a href="global.html#FS_PREFIX">FS_PREFIX</a></li><li><a href="global.html#FXAAShader">FXAAShader</a></li><li><a href="global.html#FeatureQuery">FeatureQuery</a></li><li><a href="global.html#FilmShader">FilmShader</a></li><li><a href="global.html#FocusShader">FocusShader</a></li><li><a href="global.html#FreiChenShader">FreiChenShader</a></li><li><a href="global.html#FsWatchInstances">FsWatchInstances</a></li><li><a href="global.html#GammaCorrectionShader">GammaCorrectionShader</a></li><li><a href="global.html#GodRaysCombineShader">GodRaysCombineShader</a></li><li><a href="global.html#GodRaysDepthMaskShader">GodRaysDepthMaskShader</a></li><li><a href="global.html#GodRaysFakeSunShader">GodRaysFakeSunShader</a></li><li><a href="global.html#GodRaysGenerateShader">GodRaysGenerateShader</a></li><li><a href="global.html#Gunzip">Gunzip</a></li><li><a href="global.html#Gzip">Gzip</a></li><li><a href="global.html#HalftoneShader">HalftoneShader</a></li><li><a href="global.html#HorizontalBlurShader">HorizontalBlurShader</a></li><li><a href="global.html#HorizontalTiltShiftShader">HorizontalTiltShiftShader</a></li><li><a href="global.html#HueSaturationShader">HueSaturationShader</a></li><li><a href="global.html#INFINITY">INFINITY</a></li><li><a href="global.html#IndexedSourceMapConsumer">IndexedSourceMapConsumer</a></li><li><a href="global.html#Inflate">Inflate</a></li><li><a href="global.html#Initializesframerelatedproperties.">Initializes frame related properties.</a></li><li><a href="global.html#Initializeshierarchyproperties">Initializes hierarchy properties</a></li><li><a href="global.html#KaleidoShader">KaleidoShader</a></li><li><a href="global.html#LuminosityHighPassShader">LuminosityHighPassShader</a></li><li><a href="global.html#LuminosityShader">LuminosityShader</a></li><li><a href="global.html#MATCHING_GROUP_REGEXP">MATCHING_GROUP_REGEXP</a></li><li><a href="global.html#MapSource">MapSource</a></li><li><a href="global.html#Mapping">Mapping</a></li><li><a href="global.html#MappingList">MappingList</a></li><li><a href="global.html#MirrorShader">MirrorShader</a></li><li><a href="global.html#NS">NS</a></li><li><a href="global.html#NULL_BYTE_PLACEHOLDER">NULL_BYTE_PLACEHOLDER</a></li><li><a href="global.html#Negotiator">Negotiator</a></li><li><a href="global.html#NormalMapShader">NormalMapShader</a></li><li><a href="global.html#OriginalSource">OriginalSource</a></li><li><a href="global.html#PARAM_REGEXP">PARAM_REGEXP</a></li><li><a href="global.html#POSIX_REGEX_SOURCE$1">POSIX_REGEX_SOURCE$1</a></li><li><a href="global.html#ParametricGeometries">ParametricGeometries</a></li><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#PixelShader">PixelShader</a></li><li><a href="global.html#QESC_REGEXP">QESC_REGEXP</a></li><li><a href="global.html#QUOTE_REGEXP">QUOTE_REGEXP</a></li><li><a href="global.html#REVISION">REVISION</a></li><li><a href="global.html#RGBShiftShader">RGBShiftShader</a></li><li><a href="global.html#Route">Route</a></li><li><a href="global.html#SAOShader">SAOShader</a></li><li><a href="global.html#SCALAR">SCALAR</a></li><li><a href="global.html#SMAAEdgesShader">SMAAEdgesShader</a></li><li><a href="global.html#SSAOShader">SSAOShader</a></li><li><a href="global.html#SSRShader">SSRShader</a></li><li><a href="global.html#SUBSTITUTIONS">SUBSTITUTIONS</a></li><li><a href="global.html#Searcheslayer'sparentingchain">Searches layer's parenting chain</a></li><li><a href="global.html#SepiaShader">SepiaShader</a></li><li><a href="global.html#Setslayerasparent.">Sets layer as parent.</a></li><li><a href="global.html#Setslayer'shierarchy.">Sets layer's hierarchy.</a></li><li><a href="global.html#SobelOperatorShader">SobelOperatorShader</a></li><li><a href="global.html#SourceMapGenerator">SourceMapGenerator</a></li><li><a href="global.html#SourceNode">SourceNode</a></li><li><a href="global.html#Symbol$1">Symbol$1</a></li><li><a href="global.html#TAG_ID">TAG_ID</a></li><li><a href="global.html#TYPE_REGEXP">TYPE_REGEXP</a></li><li><a href="global.html#TechnicolorShader">TechnicolorShader</a></li><li><a href="global.html#The">The</a></li><li><a href="global.html#Token">Token</a></li><li><a href="global.html#Tokenizer">Tokenizer</a></li><li><a href="global.html#ToneMapShader">ToneMapShader</a></li><li><a href="global.html#ToonShader1">ToonShader1</a></li><li><a href="global.html#TriangleBlurShader">TriangleBlurShader</a></li><li><a href="global.html#Types">Types</a></li><li><a href="global.html#UVsDebug">UVsDebug</a></li><li><a href="global.html#UniformsLib">UniformsLib</a></li><li><a href="global.html#UnpackDepthRGBAShader">UnpackDepthRGBAShader</a></li><li><a href="global.html#Unzip">Unzip</a></li><li><a href="global.html#UnzipInflate">UnzipInflate</a></li><li><a href="global.html#UnzipPassThrough">UnzipPassThrough</a></li><li><a href="global.html#Unzlib">Unzlib</a></li><li><a href="global.html#VALID_ID_PREFIX">VALID_ID_PREFIX</a></li><li><a href="global.html#VerticalBlurShader">VerticalBlurShader</a></li><li><a href="global.html#VerticalTiltShiftShader">VerticalTiltShiftShader</a></li><li><a href="global.html#View">View</a></li><li><a href="global.html#VignetteShader">VignetteShader</a></li><li><a href="global.html#Visible">Visible</a></li><li><a href="global.html#VolumeRenderShader1">VolumeRenderShader1</a></li><li><a href="global.html#WINDOWS_CHARS">WINDOWS_CHARS</a></li><li><a href="global.html#Zip">Zip</a></li><li><a href="global.html#ZipDeflate">ZipDeflate</a></li><li><a href="global.html#ZipPassThrough">ZipPassThrough</a></li><li><a href="global.html#Zlib">Zlib</a></li><li><a href="global.html#___$insertStyle">___$insertStyle</a></li><li><a href="global.html#__flow__addCSS">__flow__addCSS</a></li><li><a href="global.html#_cb">_cb</a></li><li><a href="global.html#_color">_color</a></li><li><a href="global.html#_face">_face</a></li><li><a href="global.html#_frustum">_frustum</a></li><li><a href="global.html#_position">_position</a></li><li><a href="global.html#_shadowMatrix">_shadowMatrix</a></li><li><a href="global.html#_taskCache">_taskCache</a></li><li><a href="global.html#acceptParams">acceptParams</a></li><li><a href="global.html#addEndtoBlockProps">addEndtoBlockProps</a></li><li><a href="global.html#addImportToGraph">addImportToGraph</a></li><li><a href="global.html#addMorphTargets">addMorphTargets</a></li><li><a href="global.html#addPrimitiveAttributes">addPrimitiveAttributes</a></li><li><a href="global.html#addSegment">addSegment</a></li><li><a href="global.html#alladdrs">alladdrs</a></li><li><a href="global.html#anchorIsValid">anchorIsValid</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#anymatch$1">anymatch$1</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#append">append</a></li><li><a href="global.html#application">application</a></li><li><a href="global.html#applyArabicPresentationForms">applyArabicPresentationForms</a></li><li><a href="global.html#applyArabicRequireLigatures">applyArabicRequireLigatures</a></li><li><a href="global.html#applyLatinLigatures">applyLatinLigatures</a></li><li><a href="global.html#applyReviver">applyReviver</a></li><li><a href="global.html#applySubstitution">applySubstitution</a></li><li><a href="global.html#arabicPresentationForms">arabicPresentationForms</a></li><li><a href="global.html#arabicRequiredLigatures">arabicRequiredLigatures</a></li><li><a href="global.html#arabicSentenceStartCheck">arabicSentenceStartCheck</a></li><li><a href="global.html#arabicWordStartCheck">arabicWordStartCheck</a></li><li><a href="global.html#arrayFlatten">arrayFlatten</a></li><li><a href="global.html#assignExtrasToUserData">assignExtrasToUserData</a></li><li><a href="global.html#axis">axis</a></li><li><a href="global.html#basePath">basePath</a></li><li><a href="global.html#bigEndianPlatform">bigEndianPlatform</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#bodyParser">bodyParser</a></li><li><a href="global.html#braces$1">braces$1</a></li><li><a href="global.html#braces$2">braces$2</a></li><li><a href="global.html#braces_1">braces_1</a></li><li><a href="global.html#buildSourceMapTree">buildSourceMapTree</a></li><li><a href="global.html#bytes">bytes</a></li><li><a href="global.html#callSiteLocation">callSiteLocation</a></li><li><a href="global.html#canvas">canvas</a></li><li><a href="global.html#canvasBuffer">canvasBuffer</a></li><li><a href="global.html#chainingSubstitutionFormat3">chainingSubstitutionFormat3</a></li><li><a href="global.html#chainingSubstitutionFormat3$1">chainingSubstitutionFormat3$1</a></li><li><a href="global.html#charset">charset</a></li><li><a href="global.html#checkGlyphIndexStatus">checkGlyphIndexStatus</a></li><li><a href="global.html#cleanOptions">cleanOptions</a></li><li><a href="global.html#cloneUniforms">cloneUniforms</a></li><li><a href="global.html#coerce">coerce</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#compareByGeneratedPositionsDeflated">compareByGeneratedPositionsDeflated</a></li><li><a href="global.html#compareByGeneratedPositionsInflated">compareByGeneratedPositionsInflated</a></li><li><a href="global.html#compareByOriginalPositions">compareByOriginalPositions</a></li><li><a href="global.html#compareGenerated">compareGenerated</a></li><li><a href="global.html#compileETag">compileETag</a></li><li><a href="global.html#compileQueryParser">compileQueryParser</a></li><li><a href="global.html#compileTrust">compileTrust</a></li><li><a href="global.html#compressNormals">compressNormals</a></li><li><a href="global.html#compressPositions">compressPositions</a></li><li><a href="global.html#compressUvs">compressUvs</a></li><li><a href="global.html#computeBounds">computeBounds</a></li><li><a href="global.html#computeMorphedAttributes">computeMorphedAttributes</a></li><li><a href="global.html#computeSourceURL">computeSourceURL</a></li><li><a href="global.html#consumeMoreIndentedLines">consumeMoreIndentedLines</a></li><li><a href="global.html#containsDotFile">containsDotFile</a></li><li><a href="global.html#containsNamespace">containsNamespace</a></li><li><a href="global.html#contentDisposition">contentDisposition</a></li><li><a href="global.html#contentRange">contentRange</a></li><li><a href="global.html#contentType">contentType</a></li><li><a href="global.html#contentstream">contentstream</a></li><li><a href="global.html#context">context</a></li><li><a href="global.html#convertDataDescriptorToAccessor">convertDataDescriptorToAccessor</a></li><li><a href="global.html#convertPatternsToTasks">convertPatternsToTasks</a></li><li><a href="global.html#createApplication">createApplication</a></li><li><a href="global.html#createArgumentsString">createArgumentsString</a></li><li><a href="global.html#createContext">createContext</a></li><li><a href="global.html#createDebug">createDebug</a></li><li><a href="global.html#createDefaultMaterial">createDefaultMaterial</a></li><li><a href="global.html#createError">createError</a></li><li><a href="global.html#createFSEventsInstance">createFSEventsInstance</a></li><li><a href="global.html#createFsWatchInstance">createFsWatchInstance</a></li><li><a href="global.html#createPattern">createPattern</a></li><li><a href="global.html#createScalarToken">createScalarToken</a></li><li><a href="global.html#createStackString">createStackString</a></li><li><a href="global.html#createWritableStdioStream">createWritableStdioStream</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#css">css</a></li><li><a href="global.html#ctx">ctx</a></li><li><a href="global.html#ctxBuffer">ctxBuffer</a></li><li><a href="global.html#currentlyResolving">currentlyResolving</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#debugMessage">debugMessage</a></li><li><a href="global.html#deburredLetters">deburredLetters</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#decodedMap">decodedMap</a></li><li><a href="global.html#decodedMappings">decodedMappings</a></li><li><a href="global.html#decompositionSubstitutionFormat1">decompositionSubstitutionFormat1</a></li><li><a href="global.html#decompressSync">decompressSync</a></li><li><a href="global.html#defaultComponentValues">defaultComponentValues</a></li><li><a href="global.html#defaultMessage">defaultMessage</a></li><li><a href="global.html#defineConfig">defineConfig</a></li><li><a href="global.html#deflateSync">deflateSync</a></li><li><a href="global.html#depd">depd</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#divmod32">divmod32</a></li><li><a href="global.html#dump">dump</a></li><li><a href="global.html#dynamicImport">dynamicImport</a></li><li><a href="global.html#emptyDir">emptyDir</a></li><li><a href="global.html#emptyTexture">emptyTexture</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#encloseBrace">encloseBrace</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodeUrl">encodeUrl</a></li><li><a href="global.html#encodedMap">encodedMap</a></li><li><a href="global.html#enter">enter</a></li><li><a href="global.html#equalArray">equalArray</a></li><li><a href="global.html#escapeAttribute">escapeAttribute</a></li><li><a href="global.html#escapeHtml">escapeHtml</a></li><li><a href="global.html#escapeNode">escapeNode</a></li><li><a href="global.html#escapeText">escapeText</a></li><li><a href="global.html#estimateBytesUsed">estimateBytesUsed</a></li><li><a href="global.html#etag">etag</a></li><li><a href="global.html#exceedsLimit">exceedsLimit</a></li><li><a href="global.html#expandRange">expandRange</a></li><li><a href="global.html#extendedparser">extendedparser</a></li><li><a href="global.html#extension">extension</a></li><li><a href="global.html#extractICSS$2">extractICSS$2</a></li><li><a href="global.html#fbxTree">fbxTree</a></li><li><a href="global.html#fd">fd</a></li><li><a href="global.html#fetchJsonFile">fetchJsonFile</a></li><li><a href="global.html#fieldContentRegExp">fieldContentRegExp</a></li><li><a href="global.html#fileRegex">fileRegex</a></li><li><a href="global.html#finalhandler">finalhandler</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findNewAnchor">findNewAnchor</a></li><li><a href="global.html#findNodes">findNodes</a></li><li><a href="global.html#first">first</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#flattenForever">flattenForever</a></li><li><a href="global.html#flattenWithDepth">flattenWithDepth</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#foldFlowLines">foldFlowLines</a></li><li><a href="global.html#foldNewline">foldNewline</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#formatColor">formatColor</a></li><li><a href="global.html#formatLocation">formatLocation</a></li><li><a href="global.html#formatPlain">formatPlain</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#forwarded">forwarded</a></li><li><a href="global.html#frameCorners">frameCorners</a></li><li><a href="global.html#freeGlobal">freeGlobal</a></li><li><a href="global.html#freeSelf">freeSelf</a></li><li><a href="global.html#fresh">fresh</a></li><li><a href="global.html#fromVLQSigned">fromVLQSigned</a></li><li><a href="global.html#fsWatchBroadcast">fsWatchBroadcast</a></li><li><a href="global.html#gameOver">gameOver</a></li><li><a href="global.html#generateTangents">generateTangents</a></li><li><a href="global.html#generatedPositionAfter">generatedPositionAfter</a></li><li><a href="global.html#genericNames">genericNames</a></li><li><a href="global.html#geometryNeedsUpdate">geometryNeedsUpdate</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getArg">getArg</a></li><li><a href="global.html#getCharset">getCharset</a></li><li><a href="global.html#getContextParams">getContextParams</a></li><li><a href="global.html#getContextParams$1">getContextParams$1</a></li><li><a href="global.html#getFirstKeyStartProps">getFirstKeyStartProps</a></li><li><a href="global.html#getLocalhostAddressIfDiffersFromDNS">getLocalhostAddressIfDiffersFromDNS</a></li><li><a href="global.html#getMinMax">getMinMax</a></li><li><a href="global.html#getPaddedArrayBuffer">getPaddedArrayBuffer</a></li><li><a href="global.html#getPaddedBufferSize">getPaddedBufferSize</a></li><li><a href="global.html#getPatternsInsideCurrentDirectory">getPatternsInsideCurrentDirectory</a></li><li><a href="global.html#getPatternsOutsideCurrentDirectory">getPatternsOutsideCurrentDirectory</a></li><li><a href="global.html#getRandomInt">getRandomInt</a></li><li><a href="global.html#getRawBody">getRawBody</a></li><li><a href="global.html#getStack">getStack</a></li><li><a href="global.html#getUniforms">getUniforms</a></li><li><a href="global.html#getcontenttype">getcontenttype</a></li><li><a href="global.html#globParent$1">globParent$1</a></li><li><a href="global.html#globParent$2">globParent$2</a></li><li><a href="global.html#gosper">gosper</a></li><li><a href="global.html#gunzipSync">gunzipSync</a></li><li><a href="global.html#gzipSync">gzipSync</a></li><li><a href="global.html#hasRequiredNode$1">hasRequiredNode$1</a></li><li><a href="global.html#hasbody">hasbody</a></li><li><a href="global.html#hilbert2D">hilbert2D</a></li><li><a href="global.html#hilbert3D">hilbert3D</a></li><li><a href="global.html#idToString">idToString</a></li><li><a href="global.html#index">index</a></li><li><a href="global.html#inflateSync">inflateSync</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initSplineTexture">initSplineTexture</a></li><li><a href="global.html#initializeCoreEvents">initializeCoreEvents</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#inspectorLog">inspectorLog</a></li><li><a href="global.html#interleaveAttributes">interleaveAttributes</a></li><li><a href="global.html#inverseMatrix">inverseMatrix</a></li><li><a href="global.html#isAbsolute">isAbsolute</a></li><li><a href="global.html#isArabicChar">isArabicChar</a></li><li><a href="global.html#isBigEndianPlatform">isBigEndianPlatform</a></li><li><a href="global.html#isCollection">isCollection</a></li><li><a href="global.html#isFileReadable">isFileReadable</a></li><li><a href="global.html#isFinished">isFinished</a></li><li><a href="global.html#isIdentityMatrix">isIdentityMatrix</a></li><li><a href="global.html#isInvalidBrace">isInvalidBrace</a></li><li><a href="global.html#isIsolatedArabicChar">isIsolatedArabicChar</a></li><li><a href="global.html#isLatinChar">isLatinChar</a></li><li><a href="global.html#isNonDriveRelativeAbsolutePath">isNonDriveRelativeAbsolutePath</a></li><li><a href="global.html#isOpenOrClose">isOpenOrClose</a></li><li><a href="global.html#isParentDirectory">isParentDirectory</a></li><li><a href="global.html#isScalar">isScalar</a></li><li><a href="global.html#isTashkeelArabicChar">isTashkeelArabicChar</a></li><li><a href="global.html#isWhiteSpace">isWhiteSpace</a></li><li><a href="global.html#is_reference">is_reference</a></li><li><a href="global.html#isignored">isignored</a></li><li><a href="global.html#isstats">isstats</a></li><li><a href="global.html#istraced">istraced</a></li><li><a href="global.html#join">join</a></li><li><a href="global.html#json">json</a></li><li><a href="global.html#keyPressed">keyPressed</a></li><li><a href="global.html#latinLigature">latinLigature</a></li><li><a href="global.html#latinWordStartCheck">latinWordStartCheck</a></li><li><a href="global.html#leave">leave</a></li><li><a href="global.html#ligatureSubstitutionFormat1">ligatureSubstitutionFormat1</a></li><li><a href="global.html#ligatureSubstitutionFormat1$1">ligatureSubstitutionFormat1$1</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadBushes1">loadBushes1</a></li><li><a href="global.html#loadCarriage">loadCarriage</a></li><li><a href="global.html#loadFromFile">loadFromFile</a></li><li><a href="global.html#loadFromUrl">loadFromUrl</a></li><li><a href="global.html#loadRoad">loadRoad</a></li><li><a href="global.html#loadTrees2">loadTrees2</a></li><li><a href="global.html#loadWalls">loadWalls</a></li><li><a href="global.html#loadWolf">loadWolf</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#lookup">lookup</a></li><li><a href="global.html#lookupCoverage">lookupCoverage</a></li><li><a href="global.html#lookupCoverageList">lookupCoverageList</a></li><li><a href="global.html#lowerThreshold">lowerThreshold</a></li><li><a href="global.html#lruMemoize">lruMemoize</a></li><li><a href="global.html#matchPatterns">matchPatterns</a></li><li><a href="global.html#matrix">matrix</a></li><li><a href="global.html#memoizedBinarySearch">memoizedBinarySearch</a></li><li><a href="global.html#merge">merge</a></li><li><a href="global.html#mergeBufferAttributes">mergeBufferAttributes</a></li><li><a href="global.html#mergeBufferGeometries">mergeBufferGeometries</a></li><li><a href="global.html#mergeVertices">mergeVertices</a></li><li><a href="global.html#mesh">mesh</a></li><li><a href="global.html#micromatch$1">micromatch$1</a></li><li><a href="global.html#micromatch_1">micromatch_1</a></li><li><a href="global.html#mime">mime</a></li><li><a href="global.html#ms$1">ms$1</a></li><li><a href="global.html#names">names</a></li><li><a href="global.html#nestedResolveFrom">nestedResolveFrom</a></li><li><a href="global.html#newObject">newObject</a></li><li><a href="global.html#node">node</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#normalizeAxes">normalizeAxes</a></li><li><a href="global.html#normalizeJsonSyntaxError">normalizeJsonSyntaxError</a></li><li><a href="global.html#normalizePath$5">normalizePath$5</a></li><li><a href="global.html#normalizeType">normalizeType</a></li><li><a href="global.html#normalizeTypes">normalizeTypes</a></li><li><a href="global.html#objectProto">objectProto</a></li><li><a href="global.html#objectToString">objectToString</a></li><li><a href="global.html#offset">offset</a></li><li><a href="global.html#onFinished">onFinished</a></li><li><a href="global.html#originalPositionFor">originalPositionFor</a></li><li><a href="global.html#originalPositionFor$1">originalPositionFor$1</a></li><li><a href="global.html#originalurl">originalurl</a></li><li><a href="global.html#paramRegExp">paramRegExp</a></li><li><a href="global.html#parameterCount">parameterCount</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parse$1">parse$1</a></li><li><a href="global.html#parse$f">parse$f</a></li><li><a href="global.html#parse$j">parse$j</a></li><li><a href="global.html#parseAllDocuments">parseAllDocuments</a></li><li><a href="global.html#parseBuffer">parseBuffer</a></li><li><a href="global.html#parseDocument">parseDocument</a></li><li><a href="global.html#parseOpenTypeTableEntries">parseOpenTypeTableEntries</a></li><li><a href="global.html#parseSexagesimal">parseSexagesimal</a></li><li><a href="global.html#parseSourceMapInput">parseSourceMapInput</a></li><li><a href="global.html#parseWOFFTableEntries">parseWOFFTableEntries</a></li><li><a href="global.html#parser">parser</a></li><li><a href="global.html#parsers">parsers</a></li><li><a href="global.html#parseurl">parseurl</a></li><li><a href="global.html#pathtoRegexp">pathtoRegexp</a></li><li><a href="global.html#picomatch">picomatch</a></li><li><a href="global.html#picomatch_1">picomatch_1</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#potpack">potpack</a></li><li><a href="global.html#preferredCharsets">preferredCharsets</a></li><li><a href="global.html#preferredEncodings">preferredEncodings</a></li><li><a href="global.html#preferredLanguages">preferredLanguages</a></li><li><a href="global.html#preferredMediaTypes">preferredMediaTypes</a></li><li><a href="global.html#prepareObjectStackTrace">prepareObjectStackTrace</a></li><li><a href="global.html#prettifyUrl">prettifyUrl</a></li><li><a href="global.html#prettyToken">prettyToken</a></li><li><a href="global.html#prevTime">prevTime</a></li><li><a href="global.html#processResult">processResult</a></li><li><a href="global.html#proto">proto</a></li><li><a href="global.html#proxyaddr">proxyaddr</a></li><li><a href="global.html#put">put</a></li><li><a href="global.html#qescRegExp">qescRegExp</a></li><li><a href="global.html#qstring">qstring</a></li><li><a href="global.html#quoteRegExp">quoteRegExp</a></li><li><a href="global.html#rangeParser">rangeParser</a></li><li><a href="global.html#rangeToPattern">rangeToPattern</a></li><li><a href="global.html#raw">raw</a></li><li><a href="global.html#rc">rc</a></li><li><a href="global.html#reApos">reApos</a></li><li><a href="global.html#reAsciiWord">reAsciiWord</a></li><li><a href="global.html#reComboMark">reComboMark</a></li><li><a href="global.html#reHasUnicode">reHasUnicode</a></li><li><a href="global.html#reHasUnicodeWord">reHasUnicodeWord</a></li><li><a href="global.html#reLatin">reLatin</a></li><li><a href="global.html#reUnicode">reUnicode</a></li><li><a href="global.html#reUnicodeWord">reUnicodeWord</a></li><li><a href="global.html#readByte">readByte</a></li><li><a href="global.html#readChunk">readChunk</a></li><li><a href="global.html#readColor">readColor</a></li><li><a href="global.html#readDWord">readDWord</a></li><li><a href="global.html#readFaceArray">readFaceArray</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#readFloat">readFloat</a></li><li><a href="global.html#readInt">readInt</a></li><li><a href="global.html#readMap">readMap</a></li><li><a href="global.html#readMaterialEntry">readMaterialEntry</a></li><li><a href="global.html#readMaterialGroup">readMaterialGroup</a></li><li><a href="global.html#readMesh">readMesh</a></li><li><a href="global.html#readMeshData">readMeshData</a></li><li><a href="global.html#readNamedObject">readNamedObject</a></li><li><a href="global.html#readPercentage">readPercentage</a></li><li><a href="global.html#readShort">readShort</a></li><li><a href="global.html#readStream">readStream</a></li><li><a href="global.html#readString">readString</a></li><li><a href="global.html#readWord">readWord</a></li><li><a href="global.html#readdirp$1">readdirp$1</a></li><li><a href="global.html#recursiveSearch">recursiveSearch</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#registerContextChecker">registerContextChecker</a></li><li><a href="global.html#relative">relative</a></li><li><a href="global.html#remapping">remapping</a></li><li><a href="global.html#removeDuplicateSlashes">removeDuplicateSlashes</a></li><li><a href="global.html#removedMiddlewares">removedMiddlewares</a></li><li><a href="global.html#replaceAll">replaceAll</a></li><li><a href="global.html#replacement">replacement</a></li><li><a href="global.html#req">req</a></li><li><a href="global.html#requestAnimationFrame">requestAnimationFrame</a></li><li><a href="global.html#res">res</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetObjects">resetObjects</a></li><li><a href="global.html#resolve$3">resolve$3</a></li><li><a href="global.html#reverseArabicSentences">reverseArabicSentences</a></li><li><a href="global.html#root$2">root$2</a></li><li><a href="global.html#rsApos">rsApos</a></li><li><a href="global.html#rsAstralRange">rsAstralRange</a></li><li><a href="global.html#rsLowerMisc">rsLowerMisc</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#scan$1">scan$1</a></li><li><a href="global.html#scan$2">scan$2</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#selectColor">selectColor</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#serializeOuter">serializeOuter</a></li><li><a href="global.html#serveStatic">serveStatic</a></li><li><a href="global.html#setAnchors">setAnchors</a></li><li><a href="global.html#setCharset">setCharset</a></li><li><a href="global.html#setFSEventsListener">setFSEventsListener</a></li><li><a href="global.html#setFsWatchFileListener">setFsWatchFileListener</a></li><li><a href="global.html#setFsWatchListener">setFsWatchListener</a></li><li><a href="global.html#setScalarValue">setScalarValue</a></li><li><a href="global.html#setSourceContent">setSourceContent</a></li><li><a href="global.html#setupScene">setupScene</a></li><li><a href="global.html#sha1">sha1</a></li><li><a href="global.html#should_remove">should_remove</a></li><li><a href="global.html#should_skip">should_skip</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#simpleparser">simpleparser</a></li><li><a href="global.html#singleSubstitutionFormat1">singleSubstitutionFormat1</a></li><li><a href="global.html#singleSubstitutionFormat1$1">singleSubstitutionFormat1$1</a></li><li><a href="global.html#singleSubstitutionFormat2">singleSubstitutionFormat2</a></li><li><a href="global.html#singleSubstitutionFormat2$1">singleSubstitutionFormat2$1</a></li><li><a href="global.html#sliceList">sliceList</a></li><li><a href="global.html#sortCache">sortCache</a></li><li><a href="global.html#spacing">spacing</a></li><li><a href="global.html#splitLines">splitLines</a></li><li><a href="global.html#splitType">splitType</a></li><li><a href="global.html#status">status</a></li><li><a href="global.html#strFromU8">strFromU8</a></li><li><a href="global.html#strToU8">strToU8</a></li><li><a href="global.html#stringToArrayBuffer">stringToArrayBuffer</a></li><li><a href="global.html#stringToPath">stringToPath</a></li><li><a href="global.html#stringify$2">stringify$2</a></li><li><a href="global.html#stringifyComment">stringifyComment</a></li><li><a href="global.html#stringifySexagesimal">stringifySexagesimal</a></li><li><a href="global.html#stripFilename">stripFilename</a></li><li><a href="global.html#subtypeNameRegExp">subtypeNameRegExp</a></li><li><a href="global.html#symbolProto">symbolProto</a></li><li><a href="global.html#symbolTag">symbolTag</a></li><li><a href="global.html#syntaxError">syntaxError</a></li><li><a href="global.html#syntaxError$1">syntaxError$1</a></li><li><a href="global.html#text">text</a></li><li><a href="global.html#tmpComponent">tmpComponent</a></li><li><a href="global.html#toIdentifier">toIdentifier</a></li><li><a href="global.html#toJS">toJS</a></li><li><a href="global.html#toRegexRange_1">toRegexRange_1</a></li><li><a href="global.html#toSetString">toSetString</a></li><li><a href="global.html#toTrianglesDrawMode">toTrianglesDrawMode</a></li><li><a href="global.html#toVLQSigned">toVLQSigned</a></li><li><a href="global.html#tokenType">tokenType</a></li><li><a href="global.html#tokenizeText">tokenizeText</a></li><li><a href="global.html#traceMappings">traceMappings</a></li><li><a href="global.html#traceSegment">traceSegment</a></li><li><a href="global.html#transformStableResult">transformStableResult</a></li><li><a href="global.html#triggerEvent">triggerEvent</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#typeChecker">typeChecker</a></li><li><a href="global.html#typeis">typeis</a></li><li><a href="global.html#typeofrequest">typeofrequest</a></li><li><a href="global.html#uncompressTable">uncompressTable</a></li><li><a href="global.html#unixify">unixify</a></li><li><a href="global.html#unpipe">unpipe</a></li><li><a href="global.html#unsign">unsign</a></li><li><a href="global.html#unwrapId">unwrapId</a></li><li><a href="global.html#unzip">unzip</a></li><li><a href="global.html#unzipSync">unzipSync</a></li><li><a href="global.html#unzlibSync">unzlibSync</a></li><li><a href="global.html#updateBushes1">updateBushes1</a></li><li><a href="global.html#updateCamera">updateCamera</a></li><li><a href="global.html#updateCarriage">updateCarriage</a></li><li><a href="global.html#updateMorphTargets">updateMorphTargets</a></li><li><a href="global.html#updateRoads">updateRoads</a></li><li><a href="global.html#updateSplineTexture">updateSplineTexture</a></li><li><a href="global.html#updateTrees2">updateTrees2</a></li><li><a href="global.html#updateWalls">updateWalls</a></li><li><a href="global.html#upperThreshold">upperThreshold</a></li><li><a href="global.html#urlRegex">urlRegex</a></li><li><a href="global.html#urlencoded">urlencoded</a></li><li><a href="global.html#useColors">useColors</a></li><li><a href="global.html#vary">vary</a></li><li><a href="global.html#visit">visit</a></li><li><a href="global.html#visit$1">visit$1</a></li><li><a href="global.html#visitAsync">visitAsync</a></li><li><a href="global.html#volume">volume</a></li><li><a href="global.html#walk$3">walk$3</a></li><li><a href="global.html#watch">watch</a></li><li><a href="global.html#wetag">wetag</a></li><li><a href="global.html#willConnectNext">willConnectNext</a></li><li><a href="global.html#willConnectPrev">willConnectPrev</a></li><li><a href="global.html#wrapId">wrapId</a></li><li><a href="global.html#wrapfunction">wrapfunction</a></li><li><a href="global.html#wrapproperty">wrapproperty</a></li><li><a href="global.html#xLength">xLength</a></li><li><a href="global.html#yLength">yLength</a></li><li><a href="global.html#zLength">zLength</a></li><li><a href="global.html#zip">zip</a></li><li><a href="global.html#zipSync">zipSync</a></li><li><a href="global.html#zlibSync">zlibSync</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Mon Nov 21 2022 21:10:05 GMT+0100 (Mitteleuropische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
