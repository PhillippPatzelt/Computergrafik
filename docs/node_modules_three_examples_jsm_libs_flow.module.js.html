<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/three/examples/jsm/libs/flow.module.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node_modules/three/examples/jsm/libs/flow.module.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * https://github.com/sunag/flow
 */

function __flow__addCSS( css ) {

	try {

		const style = document.createElement( 'style' );

		style.setAttribute( 'type', 'text/css' );
		style.innerHTML = css;
		document.head.appendChild( style );

	} catch ( e ) {}

}

__flow__addCSS( `@keyframes f-animation-open { 0% { transform: scale(.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; }}f-canvas,f-canvas canvas.background,f-canvas canvas.frontground { position: absolute; top: 0; left: 0; margin: 0; padding: 0; width: 100%; height: 100%; -webkit-touch-callout: none; transition: opacity .17s;}f-canvas { cursor: grab;}f-canvas canvas.frontground { z-index: 10;}body.dragging *:not(.drag) { pointer-events: none !important;}f-canvas.grabbing * { cursor: grabbing; user-select: none;}f-canvas canvas.background,f-canvas canvas.frontground { position: fixed; overflow: hidden;}f-canvas canvas.frontground { pointer-events: none;}f-canvas::-webkit-scrollbar { width: 8px; height: 8px;}f-canvas::-webkit-scrollbar-thumb:hover{ background: #014fc5;}f-canvas::-webkit-scrollbar-track { background: #363636;}f-canvas::-webkit-scrollbar-thumb { background-color: #666666; border-radius: 10px; border: 0;}f-canvas f-content { left: 0; top: 0;}f-canvas f-content,f-canvas f-area { position: absolute; display: block;}f-canvas canvas.map { position: absolute; top: 10px; right: 10px; z-index: 50; backdrop-filter: blur( 10px ); background-color: rgba( 45, 45, 48, .8 );}f-node { position: absolute; margin: 0; padding: 0; user-select: none; width: 320px; z-index: 1; cursor: auto; filter: drop-shadow(0 0 10px #00000061); backdrop-filter: blur(4px);}f-node.selected { z-index: 2;}f-canvas.focusing canvas.background,f-canvas.focusing f-node:not(.selected),f-canvas.focusing f-element f-disconnect:not(.selected) { opacity: 0; pointer-events: none;}.dragging f-canvas f-element f-disconnect { opacity: 0;}.dragging.node f-canvas.focusing canvas.background,.dragging.node f-canvas.focusing f-node:not(.selected) { opacity: .5;}f-node.selected,f-canvas.dragging-rio f-node:hover,f-canvas.dragging-lio f-node:hover { filter: drop-shadow(0 0 10px #00000061) drop-shadow(0 0 8px #4444dd);}f-node.closed f-element:not(:first-child) { display: none;}f-node.center { top: 50%; left: 50%; transform: translate( -50%, -50% );}f-node.top-right { top: 0; right: 0;}f-node.top-center { top: 0; left: 50%; transform: translateX( -50% );}f-node.top-left { top: 0; left: 0;}f-node { transition: filter 0.2s ease, opacity 0.12s ease;}f-node { animation: .2s f-animation-open 1 alternate ease-out;}f-tips,f-drop,f-menu,f-menu input,f-menu button,f-element,f-element input,f-element select,f-element button,f-element textarea { font-family: 'Open Sans', sans-serif; font-size: 13px; text-transform: capitalize; color: #eeeeee; outline: solid 0px #000; margin: 0; padding: 0; border: 0; user-select: none; -webkit-tap-highlight-color: transparent; transition: background 0.2s ease, filter 0.2s ease;}f-element input:read-only { color: #666;}f-element input,f-element textarea { text-transform: initial;}f-element input { transition: background 0.1s ease;}f-element input,f-element select,f-element button,f-element textarea { background-color: #232324d1;}f-element { position: relative; width: calc( 100% - 14px ); background: rgba(45, 45, 48, 0.95); pointer-events: auto; border-bottom: 2px solid #232323; display: flex; padding-left: 7px; padding-right: 7px; padding-top: 2px; padding-bottom: 2px;}f-element:after,f-element:before { transition: opacity .17s; opacity: 0; content: '';}f-element[tooltip]:hover:after,f-element[tooltip]:focus-within:after { font-size: 14px !important; display: flex; justify-content: center; position: fixed; margin-left: -7px; width: calc( 100% ); background: #1d1d1de8; border: 1px solid #444444a1; border-radius: 6px; color: #dadada; content: attr( tooltip ); margin-top: -41px; font-size: 16px; padding-top: 3px; padding-bottom: 3px; z-index: 10; opacity: 1; backdrop-filter: blur(4px); white-space: nowrap; overflow: hidden; text-shadow: 1px 1px 0px #0007;}f-element[tooltip]:hover:before,f-element[tooltip]:focus-within:before { border: solid; border-color: #1d1d1de8 transparent; border-width: 12px 6px 0 6px; left: calc( 50% - 6px ); bottom: 30px; position: absolute; opacity: 1; z-index: 11;}f-element[error] { background-color: #ff0000;}f-element[error]:hover:after,f-element[error]:focus-within:after { border: none; background-color: #ff0000bb; filter: drop-shadow( 2px 2px 5px #000 ); color: #fff;}f-element[error]:hover:before,f-element[error]:focus-within:before { border-color: #ff0000bb transparent;}f-element { height: 24px;}f-element input { margin-top: 2px; margin-bottom: 2px; box-shadow: inset 0px 1px 1px rgb(0 0 0 / 20%), 0px 1px 0px rgb(255 255 255 / 5%); margin-left: 2px; margin-right: 2px; width: 100%; padding-left: 4px; padding-right: 4px;}f-element input.number { cursor: col-resize;}f-element input:focus[type='text'], f-element input:focus[type='range'], f-element input:focus[type='color'] { background: rgba( 0, 0, 0, 0.6 ); outline: solid 1px rgba( 0, 80, 200, 0.98 );}f-element input[type='color'] { appearance: none; padding: 0; margin-left: 2px; margin-right: 2px; height: calc( 100% - 4px ); margin-top: 2px; border: none;}f-element input[type='color']::-webkit-color-swatch-wrapper { padding: 2px;}f-element input[type='color']::-webkit-color-swatch { border: none; cursor: alias;}f-element input[type='range'] { appearance: none; width: 100%; overflow: hidden; padding: 0; cursor: ew-resize;}f-element input[type='range']::-webkit-slider-runnable-track { appearance: none; height: 10px; color: #13bba4; margin: 0;}f-element input[type='range']::-webkit-slider-thumb { appearance: none; width: 0; background: #434343; box-shadow: -500px 0 0 500px rgba( 0, 120, 255, 0.98 ); border-radius: 50%; border: 0 !important;}f-element input[type='range']::-webkit-slider-runnable-track { margin-left: -4px; margin-right: -5px;}f-element input[type='checkbox'] { appearance: none; cursor: pointer;}f-element input[type='checkbox'].toggle { height: 20px; width: 45px; border-radius: 16px; display: inline-block; position: relative; margin: 0; margin-top: 2px; background: linear-gradient( 0deg, #292929 0%, #0a0a0ac2 100% ); transition: all 0.2s ease;}f-element input[type='checkbox'].toggle:after { content: ""; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; border-radius: 50%; background: white; box-shadow: 0 1px 2px rgba(44, 44, 44, 0.2); transition: all 0.2s cubic-bezier(0.5, 0.1, 0.75, 1.35);}f-element input[type='checkbox'].toggle:checked { background: linear-gradient( 0deg, #0177fb 0%, #0177fb 100% );}f-element input[type='checkbox'].toggle:checked:after { transform: translatex(25px);}f-element.auto-height { display: table;}f-element textarea { width: calc( 100% - 18px ); padding-top: 1px; padding-bottom: 3px; padding-left: 3px; padding-right: 8px; margin-top: 2px; margin-left: 2px; height: calc( 100% - 8px ); max-height: 300px; border-radius: 2px; resize: none; box-shadow: inset 0px 1px 1px rgb(0 0 0 / 20%), 0px 1px 0px rgb(255 255 255 / 5%);}f-element.auto-height textarea { resize: auto;}f-element select { width: 100%; margin-top: 2px; margin-bottom: 2px; margin-left: 2px; margin-right: 2px; cursor: pointer; box-shadow: inset 0px 1px 1px rgb(0 0 0 / 20%), 0px 1px 0px rgb(255 255 255 / 5%);}f-element f-toolbar { position: absolute; display: flex; top: 0; width: 100%; height: 100%; align-content: space-around;}f-element.input-right f-toolbar { right: 7px; float: right; justify-content: end;}f-element f-toolbar { margin-top: auto; margin-bottom: auto; margin-left: 3px; margin-right: 3px; font-size: 18px; line-height: 18px;}f-element f-toolbar button { opacity: .7; cursor: pointer; font-size: 14px; width: unset; height: unset; border-radius: unset; border: unset; outline: 0; background-color: unset; box-shadow: unset;}f-element f-toolbar button:hover,f-element f-toolbar button:active { opacity: 1; border: 0; background-color: unset;}f-element input.range-value { width: 60px; text-align: center;}f-menu.context button,f-element button { width: 100%; height: calc( 100% - 4px ); margin-left: 2px; margin-right: 2px; margin-top: 2px; border-radius: 3px; cursor: pointer;}f-element button { box-shadow: inset 1px 1px 1px 0 rgb(255 255 255 / 17%), inset -2px -2px 2px 0 rgb(0 0 0 / 26%);}f-element button:hover { color: #fff; background-color: #2a2a2a;}f-element button:active { border: 1px solid rgba( 0, 120, 255, 0.98 );}f-element f-inputs,f-element f-subinputs { display: flex; justify-content: flex-end; width: 100%;}f-element f-inputs { left: 100px; top: 50%; transform: translateY( -50% ); position: absolute; width: calc( 100% - 106px ); height: calc( 100% - 4px ); z-index: 1;}f-element.inputs-disable f-inputs { filter: grayscale(100%); opacity: .5;}f-element.inputs-disable f-inputs input { pointer-events: none;}f-element f-label,f-element span { margin: auto; text-shadow: 1px 1px 0px #0007;}f-element f-label { padding-left: 4px; white-space: nowrap; position: absolute; top: 50%; transform: translateY( -50% ); width: calc( 100% - 20px );}f-element.right f-label { text-align: right;}f-element.center f-label { text-align: center;}f-element f-label i { font-size: 18px; margin-right: 6px; vertical-align: sub;}f-element f-label.center { width: 100%; text-align: center; display: block;}f-element.title { height: 29px; background-color: #3a3a3ab0; background-color: #3b3b43ed; cursor: all-scroll; border-top-left-radius: 6px; border-top-right-radius: 6px;}f-element.blue { background-color: #014fc5;}f-element.red { background-color: #bd0b0b;}f-element.green { background-color: #148d05;}f-element.yellow { background-color: #d6b100;}f-element.title.left { text-align: left; display: inline-grid; justify-content: start;}f-element.title f-title { text-align: center; font-size: 15px; padding-top: 2px; position: absolute; top: 50%; transform: translateY( -50% ); width: 100%;}f-element.title i { font-size: 18px; position: absolute; right: 10px; top: 50%; transform: translateY( -50% ); opacity: .5;}f-element.title f-toolbar i { font-size: 20px; right: unset; left: 0px;}f-element.input-right.title i { left: 10px; right: unset;}f-element.title.left span { text-align: left;}f-element f-io { border: 2px solid #dadada; width: 7px; height: 7px; position: absolute; background: #242427; border-radius: 8px; float: left; left: -7px; top: calc( 50% - 5px ); cursor: alias; box-shadow: 0 0 3px 2px #0000005e; z-index: 1;}f-element f-io.connect,f-canvas.dragging-rio f-element:hover f-io.lio,f-canvas.dragging-lio f-element:hover f-io.rio { zoom: 1.4;}f-node.io-connect f-io:not(.connect) { border: 2px solid #dadada !important; zoom: 1 !important;}f-element f-io.rio { float: right; right: -7px; left: unset;}f-element f-disconnect { position: absolute; left: -35px; top: 50%; font-size: 22px; transform: translateY( -50% ); filter: drop-shadow(0 0 5px #000); text-shadow: 0px 0px 5px black; cursor: pointer; transition: all .2s;}f-element.input-right f-disconnect { right: -35px; left: unset;}f-element f-disconnect:hover { color: #ff3300;}f-element textarea::-webkit-scrollbar { width: 6px;}f-element textarea::-webkit-scrollbar-track { background: #111; } f-element textarea::-webkit-scrollbar-thumb { background: #0177fb; }f-element textarea::-webkit-scrollbar-thumb:hover { background: #1187ff; }f-element.small { height: 18px;}f-element.large { height: 36px;}f-canvas.dragging-lio f-node:not(.io-connect) f-element.rio:hover,f-canvas.dragging-rio f-node:not(.io-connect) f-element.lio:hover,f-element.select { background-color: rgba(61, 70, 82, 0.98);}f-element.invalid > f-io { zoom: 1 !important;}f-element.invalid::after { font-size: 14px !important; display: flex; justify-content: center; align-items:center; margin: auto; position: absolute; width: 100%; height: 100%; background: #bd0b0b77; vertical-align: middle; color: #fff; content: 'Not Compatible'; opacity: .95; backdrop-filter: grayscale(100%); white-space: nowrap; overflow: hidden; left: 0; top: 0; text-transform: initial;}f-drop { width: 100%; height: 100%; position: sticky; left: 0; top: 0; background: #02358417; text-align: center; justify-content: center; align-items: center; display: flex; box-shadow: inset 0 0 20px 10px #464ace17; pointer-events: none; transition: all .07s; opacity: 0; visibility: hidden;}f-drop.visible { visibility: unset; opacity: unset; transition: all .23s;}f-drop span { opacity: .5; font-size: 40px; text-shadow: 0px 0px 5px #000; font-weight: bold;}f-tooltip { pointer-events: none;}f-tooltip { position: absolute; left: 0; top: 0; background: rgba(0,0,0,.8); backdrop-filter: blur(4px); font-size: 14px; padding: 7px; left: 50%; border-radius: 10px; transform: translateX(-50%); visibility: hidden; pointer-events: none; opacity: 0; transition: all 0.3s ease; z-index: 150; white-space: nowrap;}f-menu.context,f-menu.search { position: absolute;}f-menu.context { width: 170px; z-index: 110;}f-menu.search { bottom: 85px; left: 50%; transform: translateX(-50%); z-index: 10; width: 300px;}f-menu.context f-list { display: block; margin: 0; background: #171717e6; font-size: 12px; border-radius: 6px; backdrop-filter: blur(6px); border: 1px solid #7e7e7e45; box-shadow: 3px 3px 6px rgba(0,0,0,.2); transition: opacity 0.2s ease, transform 0.1s ease;}f-menu.search f-list { margin: 0 6px 0 6px; display: flex; flex-direction: column-reverse; margin-bottom: 5px;}f-menu.context.hidden { visibility: hidden; opacity: 0;}f-menu.context f-item,f-menu.search f-item { display: block; position: relative; margin: 0; padding: 0; white-space: nowrap;}f-menu.search f-item { opacity: 0;}f-menu.context f-item.submenu::after { content: ""; position: absolute; right: 6px; top: 50%; -webkit-transform: translateY( -50% ); transform: translateY( -50% ); border: 5px solid transparent; border-left-color: #808080;}f-menu.context f-item:hover > f-menu,f-menu.context f-item.active > f-menu { visibility: unset; transform: unset; opacity: unset;}f-menu.context f-menu { top: 0px; left: calc( 100% - 4px );}f-menu.context f-item button,f-menu.search f-item button { overflow: visible; display: block; width: calc( 100% - 6px ); text-align: left; cursor: pointer; white-space: nowrap; padding: 6px 8px; border-radius: 3px; background: rgba(45, 45, 48, 0.95); border: 0; color: #ddd; margin: 3px; text-shadow: 1px 1px 0px #0007;}f-menu.context f-item button i,f-menu.search f-item button i { float: left; font-size: 16px;}f-menu.context f-item button span,f-menu.search f-item button span { margin-left: 6px;}f-menu.context f-item:hover > button,f-menu.search f-item:hover > button,f-menu.search f-item.active > button { color: #fff; background-color: rgba(61, 70, 82, 0.98);}f-menu.search f-item:hover,f-menu.search f-item.active { opacity: 1 !important;}f-menu.context f-item button:active { outline: solid 1px rgba( 0, 80, 200, 0.98 );}f-menu.context f-item f-tooltip { margin-left: 85px; top: -50px;}f-menu.search f-item { display: none;}f-menu.search f-item:nth-child(1) { opacity: 1; display: unset;}f-menu.search f-item:nth-child(2) { opacity: .8; display: unset;}f-menu.search f-item:nth-child(3) { opacity: .6; display: unset;}f-menu.search f-item:nth-child(4) { opacity: .4; display: unset;}f-menu.search f-item button { border-radius: 14px;}f-tips { right: 10px; top: 10px; position: absolute; z-index: 100; pointer-events: none; display: flex; flex-direction: column;}f-tips f-tip { width: 450px; font-size: 13px; border-radius: 6px; text-align: center; display: block; height: auto; color: #ffffffe0; margin: 4px; padding: 4px; background: #17171794; border: 1px solid #7e7e7e38; line-height: 100%; backdrop-filter: blur(6px); transition: all 0.2s ease; text-transform: initial; opacity: 0;}f-tips f-tip:nth-child(1) { opacity: 1;}f-tips f-tip:nth-child(2) { opacity: .75;}f-tips f-tip:nth-child(3) { opacity: .25;}f-tips f-tip:nth-child(4) { opacity: .1;}f-tips f-tip.error { background: #b900005e;}f-menu.search input { width: calc( 100% - 28px ); height: 41px; position: absolute; z-index: 10; border-radius: 20px; padding-left: 14px; padding-right: 14px; font-size: 15px; background-color: #17171794; border: 1px solid #7e7e7e45; backdrop-filter: blur(6px); box-shadow: 3px 3px 6px rgb(0 0 0 / 20%); text-transform: initial;}f-menu.circle { position: absolute; z-index: 100;}f-menu.circle.top { top: 40px;}f-menu.circle.left { left: 40px;}f-menu.circle.bottom { bottom: 40px;}f-menu.circle.right { right: 40px;}f-menu.circle f-item { align-content: space-around; margin-right: 20px;}f-menu.circle f-item button { width: 47px; height: 47px; font-size: 22px; background: #17171794; border-radius: 50%; backdrop-filter: blur(6px); border: 1px solid #7e7e7e45; line-height: 100%; cursor: pointer; box-shadow: 3px 3px 6px rgba(0,0,0,.2);}f-menu.circle f-item f-tooltip { margin-top: -60px;}f-menu.circle.top f-item f-tooltip { margin-top: 50px;}.f-rounded f-node f-element,.f-rounded f-node f-element.title.left { border-radius: 10px 5px 10px 5px;}.f-rounded f-node f-element input, .f-rounded f-node f-element select,.f-rounded f-node f-element button,.f-rounded f-node f-element textarea,.f-rounded f-node f-element input[type='checkbox'].toggle,.f-rounded f-node f-element input[type='checkbox'].toggle:after { border-radius: 20px 10px;}.f-rounded f-node f-element input { padding-left: 7px; padding-right: 7px;}.f-rounded f-menu.context,.f-rounded f-menu.context f-item button { border-radius: 20px 10px;}@media (hover: hover) and (pointer: fine) { f-node:not(.selected):hover { filter: drop-shadow(0 0 6px #66666630); } f-element f-toolbar { visibility: hidden; opacity: 0; transition: opacity 0.2s ease; } body:not(.connecting) f-node:hover > f-element f-toolbar { visibility: visible; opacity: 1; } f-element f-io:hover { zoom: 1.4; } f-menu.circle f-item button:hover { background-color: #2a2a2a; } f-menu.search input:hover, f-menu.search input:focus { background-color: #1a1a1a; filter: drop-shadow(0 0 6px #66666630); } f-menu.search input:focus { filter: drop-shadow(0 0 8px #4444dd); } f-menu.circle f-item button:hover > f-tooltip, f-menu.context f-item button:hover > f-tooltip { visibility: visible; opacity: 1; } f-menu.circle f-item button:hover > f-tooltip { margin-top: -50px; } f-menu.circle.top f-item button:hover > f-tooltip { margin-top: 60px; } f-menu.context f-item button:hover > f-tooltip { top: -30px; } f-menu.circle f-item button:focus > f-tooltip, f-menu.context f-item button:focus > f-tooltip { visibility: hidden; opacity: 0; }}@media (hover: none) and (pointer: coarse) { body.dragging f-canvas, body.connecting f-canvas { overflow: hidden !important; }}f-element.invalid > f-inputs,f-element.invalid > f-label,f-element.invalid > f-title,f-element.invalid > f-toolbar,f-element.invalid > input,f-element.invalid > select { opacity: .1 !important;}f-canvas { will-change: top, left;}f-node { will-change: transform !important;}` );

const REVISION = '1';

const Styles = {
	icons: {
		close: '',
		unlink: ''
	}
};

let _id = 0;

class Serializer extends EventTarget {

	constructor() {

		super();

		this._id = _id ++;

		this._serializable = true;

	}

	get id() {

		return this._id;

	}

	setSerializable( value ) {

		this._serializable = value;

		return this;

	}

	getSerializable() {

		return this._serializable;

	}

	serialize( /*data*/ ) {

		console.warn( 'Serializer: Abstract function.' );

	}

	deserialize( /*data*/ ) {

		console.warn( 'Serializer: Abstract function.' );

	}

	toJSON( data = null ) {

		let object = null;

		const id = this.id;

		if ( data !== null ) {

			const objects = data.objects;

			object = objects[ id ];

			if ( object === undefined ) {

				object = { objects };

				this.serialize( object );

				delete object.objects;

				objects[ id ] = object;

			}

		} else {

			object = { objects: {} };

			this.serialize( object );

		}

		object.id = id;
		object.type = this.constructor.name;

		return object;

	}

}

class PointerMonitor {

	started = false;

	constructor() {

		this.x = 0;
		this.y = 0;

		this._onMoveEvent = ( e ) => {

			const event = e.touches ? e.touches[ 0 ] : e;

			this.x = event.clientX;
			this.y = event.clientY;

		};

	}

	start() {

		if ( this.started ) return;

		this.started = true;

		window.addEventListener( 'wheel', this._onMoveEvent, true );

		window.addEventListener( 'mousedown', this._onMoveEvent, true );
		window.addEventListener( 'touchstart', this._onMoveEvent, true );

		window.addEventListener( 'mousemove', this._onMoveEvent, true );
		window.addEventListener( 'touchmove', this._onMoveEvent, true );

		window.addEventListener( 'dragover', this._onMoveEvent, true );

		return this;

	}

}

const pointer = new PointerMonitor().start();

const draggableDOM = ( dom, callback = null, settings = {} ) => {

	settings = Object.assign( {
		className: 'dragging',
		click: false,
		bypass: false
	}, settings );

	let dragData = null;

	const { className, click, bypass } = settings;

	const getZoom = () => {

		let zoomDOM = dom;

		while ( zoomDOM &amp;&amp; zoomDOM !== document ) {

			const zoom = zoomDOM.style.zoom;

			if ( zoom ) {

				return Number( zoom );

			}

			zoomDOM = zoomDOM.parentNode;

		}

		return 1;

	};

	const onMouseDown = ( e ) => {

		const event = e.touches ? e.touches[ 0 ] : e;

		if ( bypass === false ) e.stopImmediatePropagation();

		dragData = {
			client: { x: event.clientX, y: event.clientY },
			delta: { x: 0, y: 0 },
			start: { x: dom.offsetLeft, y: dom.offsetTop },
			frame: 0,
			isDown: true,
			dragging: false,
			isTouch: !! e.touches
		};

		if ( click === true ) {

			callback( dragData );

			dragData.frame ++;

		}

		window.addEventListener( 'mousemove', onGlobalMouseMove );
		window.addEventListener( 'mouseup', onGlobalMouseUp );

		window.addEventListener( 'touchmove', onGlobalMouseMove );
		window.addEventListener( 'touchend', onGlobalMouseUp );

	};

	const onGlobalMouseMove = ( e ) => {

		const { start, delta, client } = dragData;

		const event = e.touches ? e.touches[ 0 ] : e;

		const zoom = getZoom();

		delta.x = ( event.clientX - client.x ) / zoom;
		delta.y = ( event.clientY - client.y ) / zoom;

		dragData.x = start.x + delta.x;
		dragData.y = start.y + delta.y;

		if ( dragData.dragging === true ) {

			if ( callback !== null ) {

				callback( dragData );

				dragData.frame ++;

			} else {

				dom.style.cssText += `; left: ${ dragData.x }px; top: ${ dragData.y }px;`;

			}

			if ( bypass === false ) e.stopImmediatePropagation();

		} else {

			if ( Math.abs( delta.x ) > 2 || Math.abs( delta.y ) > 2 ) {

				dragData.dragging = true;

				dom.classList.add( 'drag' );

				if ( className ) document.body.classList.add( ...className.split( ' ' ) );

				if ( bypass === false ) e.stopImmediatePropagation();

			}

		}

	};

	const onGlobalMouseUp = ( e ) => {

		if ( bypass === false ) e.stopImmediatePropagation();

		dom.classList.remove( 'drag' );

		if ( className ) document.body.classList.remove( ...className.split( ' ' ) );

		window.removeEventListener( 'mousemove', onGlobalMouseMove );
		window.removeEventListener( 'mouseup', onGlobalMouseUp );

		window.removeEventListener( 'touchmove', onGlobalMouseMove );
		window.removeEventListener( 'touchend', onGlobalMouseUp );

		if ( callback === null ) {

			dom.removeEventListener( 'mousedown', onMouseDown );
			dom.removeEventListener( 'touchstart', onMouseDown );

		}

		dragData.dragging = false;
		dragData.isDown = false;

		if ( callback !== null ) {

			callback( dragData );

			dragData.frame ++;

		}

	};

	if ( dom instanceof Event ) {

		const e = dom;
		dom = e.target;

		onMouseDown( e );

	} else {

		dom.addEventListener( 'mousedown', onMouseDown );
		dom.addEventListener( 'touchstart', onMouseDown );

	}

};

const dispatchEventList = ( list, ...params ) => {

	for ( const callback of list ) {

		if ( callback( ...params ) === false ) {

			return false;

		}

	}

	return true;

};

const numberToPX = ( val ) => {

	if ( isNaN( val ) === false ) {

		val = `${ val }px`;

	}

	return val;

};

const numberToHex = ( val ) => {

	if ( isNaN( val ) === false ) {

		val = `#${ val.toString( 16 ).padStart( 6, '0' ) }`;

	}

	return val;

};

const rgbaToArray = ( rgba ) => {

	const values = rgba.substring( rgba.indexOf( '(' ) + 1, rgba.indexOf( ')' ) )
		.split( ',' )
		.map( num => parseInt( num.trim() ) );

	return values;

};

const removeDOMClass = ( dom, classList ) => {

	if ( classList ) classList.split( ' ' ).forEach( alignClass => dom.classList.remove( alignClass ) );

};

const addDOMClass = ( dom, classList ) => {

	if ( classList ) classList.split( ' ' ).forEach( alignClass => dom.classList.add( alignClass ) );

};

var Utils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	pointer: pointer,
	draggableDOM: draggableDOM,
	dispatchEventList: dispatchEventList,
	numberToPX: numberToPX,
	numberToHex: numberToHex,
	rgbaToArray: rgbaToArray,
	removeDOMClass: removeDOMClass,
	addDOMClass: addDOMClass
});

class Link {

	constructor( inputElement = null, outputElement = null ) {

		this.inputElement = inputElement;
		this.outputElement = outputElement;

	}

	get lioElement() {

		if ( Link.InputDirection === 'left' ) {

			return this.outputElement;

		} else {

			return this.inputElement;

		}

	}

	get rioElement() {

		if ( Link.InputDirection === 'left' ) {

			return this.inputElement;

		} else {

			return this.outputElement;

		}

	}

}

//Link.InputDirection = 'right';
Link.InputDirection = 'left';

let selected = null;

class Element extends Serializer {

	constructor( draggable = false ) {

		super();

		const dom = document.createElement( 'f-element' );
		dom.element = this;

		const onSelect = ( e ) => {

			let element = this;

			if ( e.changedTouches &amp;&amp; e.changedTouches.length > 0 ) {

				const touch = e.changedTouches[ 0 ];

				let overDOM = document.elementFromPoint( touch.clientX, touch.clientY );

				while ( overDOM &amp;&amp; ( ! overDOM.element || ! overDOM.element.isElement ) ) {

					overDOM = overDOM.parentNode;

				}

				element = overDOM ? overDOM.element : null;

			}

			const type = e.type;

			if ( ( type === 'mouseout' ) &amp;&amp; selected === element ) {

				selected = null;

			} else {

				selected = element;

			}

		};

		if ( draggable === false ) {

			dom.ontouchstart = dom.onmousedown = ( e ) => {

				e.stopPropagation();

			};

		}

		dom.addEventListener( 'mouseup', onSelect, true );
		dom.addEventListener( 'mouseover', onSelect );
		dom.addEventListener( 'mouseout', onSelect );
		dom.addEventListener( 'touchmove', onSelect );
		dom.addEventListener( 'touchend', onSelect );

		this.inputs = [];

		this.links = [];

		this.dom = dom;

		this.lioLength = 0;
		this.rioLength = 0;

		this.events = {
			'connect': [],
			'connectChildren': [],
			'valid': []
		};

		this.node = null;

		this.style = '';
		this.color = null;

		this.object = null;
		this.objectCallback = null;

		this.enabledInputs = true;

		this.visible = true;

		this.inputsDOM = dom;

		this.disconnectDOM = null;

		this.lioDOM = this._createIO( 'lio' );
		this.rioDOM = this._createIO( 'rio' );

		this.dom.classList.add( `input-${ Link.InputDirection }` );

		this.addEventListener( 'connect', ( ) => {

			dispatchEventList( this.events.connect, this );

		} );

		this.addEventListener( 'connectChildren', ( ) => {

			dispatchEventList( this.events.connectChildren, this );

		} );

	}

	setAttribute( name, value ) {

		this.dom.setAttribute( name, value );

		return this;

	}

	onValid( callback ) {

		this.events.valid.push( callback );

		return this;

	}

	onConnect( callback, childrens = false ) {

		this.events.connect.push( callback );

		if ( childrens ) {

			this.events.connectChildren.push( callback );

		}

		return this;

	}

	setObjectCallback( callback ) {

		this.objectCallback = callback;

		return this;

	}

	setObject( value ) {

		this.object = value;

		return this;

	}

	getObject( output = null ) {

		return this.objectCallback ? this.objectCallback( output ) : this.object;

	}

	setVisible( value ) {

		this.visible = value;

		this.dom.style.display = value ? '' : 'none';

		return this;

	}

	getVisible() {

		return this.visible;

	}

	setEnabledInputs( value ) {

		const dom = this.dom;

		if ( ! this.enabledInputs ) dom.classList.remove( 'inputs-disable' );

		if ( ! value ) dom.classList.add( 'inputs-disable' );

		this.enabledInputs = value;

		return this;

	}

	getEnabledInputs() {

		return this.enabledInputs;

	}

	setColor( color ) {

		this.dom.style[ 'background-color' ] = numberToHex( color );
		this.color = null;

		return this;

	}

	getColor() {

		if ( this.color === null ) {

			const css = window.getComputedStyle( this.dom );

			this.color = css.getPropertyValue( 'background-color' );

		}

		return this.color;

	}

	setStyle( style ) {

		const dom = this.dom;

		if ( this.style ) dom.classList.remove( this.style );

		if ( style ) dom.classList.add( style );

		this.style = style;
		this.color = null;

		return this;

	}

	setInput( length ) {

		if ( Link.InputDirection === 'left' ) {

			return this.setLIO( length );

		} else {

			return this.setRIO( length );

		}

	}

	setInputColor( color ) {

		if ( Link.InputDirection === 'left' ) {

			return this.setLIOColor( color );

		} else {

			return this.setRIOColor( color );

		}

	}

	setOutput( length ) {

		if ( Link.InputDirection === 'left' ) {

			return this.setRIO( length );

		} else {

			return this.setLIO( length );

		}

	}

	setOutputColor( color ) {

		if ( Link.InputDirection === 'left' ) {

			return this.setRIOColor( color );

		} else {

			return this.setLIOColor( color );

		}

	}

	get inputLength() {

		if ( Link.InputDirection === 'left' ) {

			return this.lioLength;

		} else {

			return this.rioLength;

		}

	}

	get outputLength() {

		if ( Link.InputDirection === 'left' ) {

			return this.rioLength;

		} else {

			return this.lioLength;

		}

	}

	setLIOColor( color ) {

		this.lioDOM.style[ 'border-color' ] = numberToHex( color );

		return this;

	}

	setLIO( length ) {

		this.lioLength = length;

		this.lioDOM.style.visibility = length > 0 ? '' : 'hidden';

		if ( length > 0 ) {

			this.dom.classList.add( 'lio' );
			this.dom.prepend( this.lioDOM );

		} else {

			this.dom.classList.remove( 'lio' );
			this.lioDOM.remove();

		}

		return this;

	}

	getLIOColor() {

		return this.lioDOM.style[ 'border-color' ];

	}

	setRIOColor( color ) {

		this.rioDOM.style[ 'border-color' ] = numberToHex( color );

		return this;

	}

	getRIOColor() {

		return this.rioDOM.style[ 'border-color' ];

	}

	setRIO( length ) {

		this.rioLength = length;

		this.rioDOM.style.visibility = length > 0 ? '' : 'hidden';

		if ( length > 0 ) {

			this.dom.classList.add( 'rio' );
			this.dom.prepend( this.rioDOM );

		} else {

			this.dom.classList.remove( 'rio' );
			this.rioDOM.remove();

		}

		return this;

	}

	add( input ) {

		this.inputs.push( input );

		input.element = this;

		this.inputsDOM.append( input.dom );

		return this;

	}

	setHeight( val ) {

		this.dom.style.height = numberToPX( val );

		return this;

	}

	getHeight() {

		return this.dom.style.height;

	}

	connect( element = null ) {

		if ( this.disconnectDOM !== null ) {

			// remove the current input

			this.disconnectDOM.dispatchEvent( new Event( 'disconnect' ) );

		}

		if ( element !== null ) {

			element = element.baseElement || element;

			if ( dispatchEventList( this.events.valid, this, element, 'connect' ) === false ) {

				return false;

			}

			const link = new Link( this, element );

			this.links.push( link );

			if ( this.disconnectDOM === null ) {

				this.disconnectDOM = document.createElement( 'f-disconnect' );
				this.disconnectDOM.innerHTML = Styles.icons.unlink ? `&lt;i class='${ Styles.icons.unlink }'>&lt;/i>` : '✖';

				this.dom.append( this.disconnectDOM );

				const onDisconnect = () => {

					this.links = [];
					this.dom.removeChild( this.disconnectDOM );

					this.disconnectDOM.removeEventListener( 'mousedown', onClick, true );
					this.disconnectDOM.removeEventListener( 'touchstart', onClick, true );
					this.disconnectDOM.removeEventListener( 'disconnect', onDisconnect, true );

					element.removeEventListener( 'connect', onConnect );
					element.removeEventListener( 'connectChildren', onConnect );
					element.removeEventListener( 'nodeConnect', onConnect );
					element.removeEventListener( 'nodeConnectChildren', onConnect );
					element.removeEventListener( 'dispose', onDispose );

					this.disconnectDOM = null;

				};

				const onConnect = () => {

					this.dispatchEvent( new Event( 'connectChildren' ) );

				};

				const onDispose = () => {

					this.connect();

				};

				const onClick = ( e ) => {

					e.stopPropagation();

					this.connect();

				};

				this.disconnectDOM.addEventListener( 'mousedown', onClick, true );
				this.disconnectDOM.addEventListener( 'touchstart', onClick, true );
				this.disconnectDOM.addEventListener( 'disconnect', onDisconnect, true );

				element.addEventListener( 'connect', onConnect );
				element.addEventListener( 'connectChildren', onConnect );
				element.addEventListener( 'nodeConnect', onConnect );
				element.addEventListener( 'nodeConnectChildren', onConnect );
				element.addEventListener( 'dispose', onDispose );

			}

		}

		this.dispatchEvent( new Event( 'connect' ) );

		return true;

	}

	dispose() {

		this.dispatchEvent( new Event( 'dispose' ) );

	}

	serialize( data ) {

		const height = this.getHeight();

		const inputs = [];
		const links = [];

		for ( const input of this.inputs ) {

			inputs.push( input.toJSON( data ).id );

		}

		for ( const link of this.links ) {

			if ( link.inputElement !== null &amp;&amp; link.outputElement !== null ) {

				links.push( link.outputElement.toJSON( data ).id );

			}

		}

		if ( this.inputLength > 0 ) data.inputLength = this.inputLength;
		if ( this.outputLength > 0 ) data.outputLength = this.outputLength;

		if ( inputs.length > 0 ) data.inputs = inputs;
		if ( links.length > 0 ) data.links = links;

		if ( this.style !== '' ) {

			data.style = this.style;

		}

		if ( height !== '' ) {

			data.height = height;

		}

	}

	deserialize( data ) {

		if ( data.inputLength !== undefined ) this.setInput( data.inputLength );
		if ( data.outputLength !== undefined ) this.setOutput( data.outputLength );

		if ( data.inputs !== undefined ) {

			const inputs = this.inputs;

			if ( inputs.length > 0 ) {

				let index = 0;

				for ( const id of data.inputs ) {

					data.objects[ id ] = inputs[ index ++ ];

				}

			} else {

				for ( const id of data.inputs ) {

					this.add( data.objects[ id ] );

				}

			}

		}

		if ( data.links !== undefined ) {

			for ( const id of data.links ) {

				this.connect( data.objects[ id ] );

			}

		}

		if ( data.style !== undefined ) {

			this.setStyle( data.style );

		}

		if ( data.height !== undefined ) {

			this.setHeight( data.height );

		}

	}

	getLinkedObject( output = null ) {

		const linkedElement = this.getLinkedElement();

		return linkedElement ? linkedElement.getObject( output ) : null;

	}

	getLinkedElement() {

		const link = this.getLink();

		return link ? link.outputElement : null;

	}

	getLink() {

		return this.links[ 0 ];

	}

	_createIO( type ) {

		const { dom } = this;

		const ioDOM = document.createElement( 'f-io' );
		ioDOM.style.visibility = 'hidden';
		ioDOM.className = type;

		const onConnectEvent = ( e ) => {

			e.preventDefault();

			e.stopPropagation();

			selected = null;

			const nodeDOM = this.node.dom;

			nodeDOM.classList.add( 'io-connect' );

			ioDOM.classList.add( 'connect' );
			dom.classList.add( 'select' );

			const defaultOutput = Link.InputDirection === 'left' ? 'lio' : 'rio';

			const link = type === defaultOutput ? new Link( this ) : new Link( null, this );
			const previewLink = new Link( link.inputElement, link.outputElement );

			this.links.push( link );

			draggableDOM( e, ( data ) => {

				if ( previewLink.outputElement )
					previewLink.outputElement.dom.classList.remove( 'invalid' );

				if ( previewLink.inputElement )
					previewLink.inputElement.dom.classList.remove( 'invalid' );

				previewLink.inputElement = link.inputElement;
				previewLink.outputElement = link.outputElement;

				if ( type === defaultOutput ) {

					previewLink.outputElement = selected;

				} else {

					previewLink.inputElement = selected;

				}

				const isInvalid = previewLink.inputElement !== null &amp;&amp; previewLink.outputElement !== null &amp;&amp;
					previewLink.inputElement.inputLength > 0 &amp;&amp; previewLink.outputElement.outputLength > 0 &amp;&amp;
					dispatchEventList( previewLink.inputElement.events.valid, previewLink.inputElement, previewLink.outputElement, data.dragging ? 'dragging' : 'dragged' ) === false;

				if ( data.dragging &amp;&amp; isInvalid ) {

					if ( type === defaultOutput ) {

						if ( previewLink.outputElement )
							previewLink.outputElement.dom.classList.add( 'invalid' );

					} else {

						if ( previewLink.inputElement )
							previewLink.inputElement.dom.classList.add( 'invalid' );

					}

					return;

				}

				if ( ! data.dragging ) {

					nodeDOM.classList.remove( 'io-connect' );

					ioDOM.classList.remove( 'connect' );
					dom.classList.remove( 'select' );

					this.links.splice( this.links.indexOf( link ), 1 );

					if ( selected !== null &amp;&amp; ! isInvalid ) {

						link.inputElement = previewLink.inputElement;
						link.outputElement = previewLink.outputElement;

						// check if is an is circular link

						if ( link.outputElement.node.isCircular( link.inputElement.node ) ) {

							return;

						}

						//

						if ( link.inputElement.inputLength > 0 &amp;&amp; link.outputElement.outputLength > 0 ) {

							link.inputElement.connect( link.outputElement );

						}

					}

				}

			}, { className: 'connecting' } );

		};

		ioDOM.addEventListener( 'mousedown', onConnectEvent, true );
		ioDOM.addEventListener( 'touchstart', onConnectEvent, true );

		return ioDOM;

	}

}

Element.prototype.isElement = true;

class Input extends Serializer {

	constructor( dom ) {

		super();

		this.dom = dom;

		this.element = null;

		this.extra = null;

		this.tagColor = null;

		this.events = {
			'change': [],
			'click': []
		};

		this.addEventListener( 'change', ( ) => {

			dispatchEventList( this.events.change, this );

		} );

		this.addEventListener( 'click', ( ) => {

			dispatchEventList( this.events.click, this );

		} );

	}

	setExtra( value ) {

		this.extra = value;

		return this;

	}

	getExtra() {

		return this.extra;

	}

	setTagColor( color ) {

		this.tagColor = color;

		this.dom.style[ 'border-left' ] = `2px solid ${color}`;

		return this;

	}

	getTagColor() {

		return this.tagColor;

	}

	setToolTip( text ) {

		const div = document.createElement( 'f-tooltip' );
		div.innerText = text;

		this.dom.append( div );

		return this;

	}

	onChange( callback ) {

		this.events.change.push( callback );

		return this;

	}

	onClick( callback ) {

		this.events.click.push( callback );

		return this;

	}

	setReadOnly( value ) {

		this.dom.readOnly = value;

		return this;

	}

	getReadOnly() {

		return this.dom.readOnly;

	}

	setValue( value, dispatch = true ) {

		this.dom.value = value;

		if ( dispatch ) this.dispatchEvent( new Event( 'change' ) );

		return this;

	}

	getValue() {

		return this.dom.value;

	}

	serialize( data ) {

		data.value = this.getValue();

	}

	deserialize( data ) {

		this.setValue( data.value );

	}

}

Input.prototype.isInput = true;

class Node extends Serializer {

	constructor() {

		super();

		const dom = document.createElement( 'f-node' );

		const onDown = () => {

			const canvas = this.canvas;

			if ( canvas !== null ) {

				canvas.select( this );

			}

		};

		dom.addEventListener( 'mousedown', onDown, true );
		dom.addEventListener( 'touchstart', onDown, true );

		this._onConnect = ( e ) => {

			const { target } = e;

			for ( const element of this.elements ) {

				if ( element !== target ) {

					element.dispatchEvent( new Event( 'nodeConnect' ) );

				}

			}

		};

		this._onConnectChildren = ( e ) => {

			const { target } = e;

			for ( const element of this.elements ) {

				if ( element !== target ) {

					element.dispatchEvent( new Event( 'nodeConnectChildren' ) );

				}

			}

		};

		this.dom = dom;

		this.style = '';

		this.canvas = null;

		this.elements = [];

		this.events = {
			'focus': [],
			'blur': []
		};

		this.setWidth( 300 ).setPosition( 0, 0 );

	}

	get baseElement() {

		return this.elements[ 0 ];

	}

	onFocus( callback ) {

		this.events.focus.push( callback );

		return this;

	}

	onBlur( callback ) {

		this.events.blur.push( callback );

		return this;

	}

	setStyle( style ) {

		const dom = this.dom;

		if ( this.style ) dom.classList.remove( this.style );

		if ( style ) dom.classList.add( style );

		this.style = style;

		return this;

	}

	setPosition( x, y ) {

		const dom = this.dom;

		dom.style.left = numberToPX( x );
		dom.style.top = numberToPX( y );

		return this;

	}

	getPosition() {

		const dom = this.dom;

		return {
			x: parseInt( dom.style.left ),
			y: parseInt( dom.style.top )
		};

	}

	setWidth( val ) {

		this.dom.style.width = numberToPX( val );

		return this;

	}

	getWidth() {

		return parseInt( this.dom.style.width );

	}

	getHeight() {

		return this.dom.offsetHeight;

	}

	getBound() {

		const { x, y } = this.getPosition();
		const width = this.getWidth();
		const height = this.getHeight();

		return { x, y, width, height };

	}

	add( element ) {

		this.elements.push( element );

		element.node = this;
		element.addEventListener( 'connect', this._onConnect );
		element.addEventListener( 'connectChildren', this._onConnectChildren );

		this.dom.append( element.dom );

		return this;

	}

	remove( element ) {

		this.elements.splice( this.elements.indexOf( element ), 1 );

		element.node = null;
		element.removeEventListener( 'connect', this._onConnect );
		element.removeEventListener( 'connectChildren', this._onConnectChildren );

		this.dom.removeChild( element.dom );

		return this;

	}

	dispose() {

		const canvas = this.canvas;

		if ( canvas !== null ) canvas.remove( this );

		for ( const element of this.elements ) {

			element.dispose();

		}

		this.dispatchEvent( new Event( 'dispose' ) );

	}

	isCircular( node ) {

		if ( node === this ) return true;

		const links = this.getLinks();

		for ( const link of links ) {

			if ( link.outputElement.node.isCircular( node ) ) {

				return true;

			}

		}

		return false;

	}

	getLinks() {

		const links = [];

		for ( const element of this.elements ) {

			links.push( ...element.links );

		}

		return links;

	}

	getColor() {

		return this.elements[ 0 ]?.getColor();

	}

	serialize( data ) {

		const { x, y } = this.getPosition();

		const elements = [];

		for ( const element of this.elements ) {

			elements.push( element.toJSON( data ).id );

		}

		data.x = x;
		data.y = y;
		data.width = this.getWidth();
		data.elements = elements;

		if ( this.style !== '' ) {

			data.style = this.style;

		}

	}

	deserialize( data ) {

		this.setPosition( data.x, data.y );
		this.setWidth( data.width );

		if ( data.style !== undefined ) {

			this.setStyle( data.style );

		}

		const elements = this.elements;

		if ( elements.length > 0 ) {

			let index = 0;

			for ( const id of data.elements ) {

				data.objects[ id ] = elements[ index ++ ];

			}

		} else {

			for ( const id of data.elements ) {

				this.add( data.objects[ id ] );

			}

		}

	}

}

Node.prototype.isNode = true;

class DraggableElement extends Element {

	constructor( draggable = true ) {

		super( true );

		this.draggable = draggable;

		const onDrag = ( e ) => {

			e.preventDefault();

			if ( this.draggable === true ) {

				draggableDOM( this.node.dom, null, { className: 'dragging node' } );

			}

		};

		const { dom } = this;

		dom.addEventListener( 'mousedown', onDrag, true );
		dom.addEventListener( 'touchstart', onDrag, true );

	}

}

class TitleElement extends DraggableElement {

	constructor( title, draggable = true ) {

		super( draggable );

		const { dom } = this;

		dom.className = 'title';

		const dbClick = () => {

			this.node.canvas.focusSelected = ! this.node.canvas.focusSelected;

		};

		dom.addEventListener( 'dblclick', dbClick );

		const titleDOM = document.createElement( 'f-title' );
		titleDOM.innerText = title;

		const iconDOM = document.createElement( 'i' );

		const toolbarDOM = document.createElement( 'f-toolbar' );

		this.buttons = [];

		this.titleDOM = titleDOM;
		this.iconDOM = iconDOM;
		this.toolbarDOM = toolbarDOM;

		dom.append( titleDOM );
		dom.append( iconDOM );
		dom.append( toolbarDOM );

	}

	setIcon( value ) {

		this.iconDOM.className = value;

		return this;

	}

	getIcon() {

		return this.iconDOM.className;

	}

	setTitle( value ) {

		this.titleDOM.innerText = value;

		return this;

	}

	getTitle() {

		return this.titleDOM.innerText;

	}

	addButton( button ) {

		this.buttons.push( button );

		this.toolbarDOM.append( button.dom );

		return this;

	}

	serialize( data ) {

		super.serialize( data );

		const title = this.getTitle();
		const icon = this.getIcon();

		data.title = title;

		if ( icon !== '' ) {

			data.icon = icon;

		}

	}

	deserialize( data ) {

		super.deserialize( data );

		this.setTitle( data.title );

		if ( data.icon !== undefined ) {

			this.setIcon( data.icon );

		}

	}

}

const drawLine = ( p1x, p1y, p2x, p2y, invert, size, colorA, ctx, colorB = null ) => {

	const dx = p2x - p1x;
	const dy = p2y - p1y;
	const offset = Math.sqrt( ( dx * dx ) + ( dy * dy ) ) * ( invert ? - .3 : .3 );

	ctx.beginPath();

	ctx.moveTo( p1x, p1y );

	ctx.bezierCurveTo(
		p1x + offset, p1y,
		p2x - offset, p2y,
		p2x, p2y
	);

	if ( colorB !== null &amp;&amp; colorA !== colorB ) {

		const gradient = ctx.createLinearGradient( p1x, p1y, p2x, p2y );
		gradient.addColorStop( 0, colorA );
		gradient.addColorStop( 1, colorB );

		ctx.strokeStyle = gradient;

	} else {

		ctx.strokeStyle = colorA;

	}

	ctx.lineWidth = size;
	ctx.stroke();

};

const colors = [
	'#ff4444',
	'#44ff44',
	'#4444ff'
];

const dropNode = new Node().add( new TitleElement( 'File' ) ).setWidth( 250 );

class Canvas extends Serializer {

	constructor() {

		super();

		const dom = document.createElement( 'f-canvas' );
		const contentDOM = document.createElement( 'f-content' );
		const areaDOM = document.createElement( 'f-area' );
		const dropDOM = document.createElement( 'f-drop' );

		const canvas = document.createElement( 'canvas' );
		const frontCanvas = document.createElement( 'canvas' );
		const mapCanvas = document.createElement( 'canvas' );

		const context = canvas.getContext( '2d' );
		const frontContext = frontCanvas.getContext( '2d' );
		const mapContext = mapCanvas.getContext( '2d' );

		this.dom = dom;

		this.contentDOM = contentDOM;
		this.areaDOM = areaDOM;
		this.dropDOM = dropDOM;

		this.canvas = canvas;
		this.frontCanvas = frontCanvas;
		this.mapCanvas = mapCanvas;

		this.context = context;
		this.frontContext = frontContext;
		this.mapContext = mapContext;

		this.clientX = 0;
		this.clientY = 0;

		this.relativeClientX = 0;
		this.relativeClientY = 0;

		this.nodes = [];

		this.selected = null;

		this.updating = false;

		this.droppedItems = [];

		this.events = {
			'drop': []
		};

		this._scrollLeft = 0;
		this._scrollTop = 0;
		this._zoom = 1;
		this._width = 0;
		this._height = 0;
		this._focusSelected = false;
		this._mapInfo = {
			scale: 1,
			screen: {}
		};

		canvas.className = 'background';
		frontCanvas.className = 'frontground';
		mapCanvas.className = 'map';

		dropDOM.innerHTML = '&lt;span>drop your file&lt;/span>';

		dom.append( dropDOM );
		dom.append( canvas );
		dom.append( frontCanvas );
		dom.append( contentDOM );
		dom.append( areaDOM );
		dom.append( mapCanvas );

		const zoomTo = ( zoom, clientX = this.clientX, clientY = this.clientY ) => {

			zoom = Math.min( Math.max( zoom, .2 ), 1 );

			this.scrollLeft -= ( clientX / this.zoom ) - ( clientX / zoom );
			this.scrollTop -= ( clientY / this.zoom ) - ( clientY / zoom );
			this.zoom = zoom;

		};

		let touchData = null;

		const onTouchStart = () => {

			touchData = null;

		};

		const onMouseZoom = ( e ) => {

			e.preventDefault();

			e.stopImmediatePropagation();

			const delta = e.deltaY * .003;

			zoomTo( this.zoom - delta );

		};

		const onTouchZoom = ( e ) => {

			if ( e.touches &amp;&amp; e.touches.length === 2 ) {

				e.preventDefault();

				e.stopImmediatePropagation();

				const clientX = ( e.touches[ 0 ].clientX + e.touches[ 1 ].clientX ) / 2;
				const clientY = ( e.touches[ 0 ].clientY + e.touches[ 1 ].clientY ) / 2;

				const distance = Math.hypot(
					e.touches[ 0 ].clientX - e.touches[ 1 ].clientX,
					e.touches[ 0 ].clientY - e.touches[ 1 ].clientY
				);

				if ( touchData === null ) {

					touchData = {
						distance
					};

				}

				const delta = ( touchData.distance - distance ) * .003;
				touchData.distance = distance;

				zoomTo( this.zoom - delta, clientX, clientY );

			}

		};

		const onTouchMove = ( e ) => {

			if ( e.touches &amp;&amp; e.touches.length === 1 ) {

				e.preventDefault();

				e.stopImmediatePropagation();

				const clientX = e.touches[ 0 ].clientX;
				const clientY = e.touches[ 0 ].clientY;

				if ( touchData === null ) {

					const { scrollLeft, scrollTop } = this;

					touchData = {
						scrollLeft,
						scrollTop,
						clientX,
						clientY
					};

				}

				const zoom = this.zoom;

				this.scrollLeft = touchData.scrollLeft + ( ( clientX - touchData.clientX ) / zoom );
				this.scrollTop = touchData.scrollTop + ( ( clientY - touchData.clientY ) / zoom );

			}

		};

		dom.addEventListener( 'wheel', onMouseZoom );
		dom.addEventListener( 'touchmove', onTouchZoom );
		dom.addEventListener( 'touchstart', onTouchStart );
		canvas.addEventListener( 'touchmove', onTouchMove );

		let dropEnterCount = 0;

		const dragState = ( enter ) => {

			if ( enter ) {

				if ( dropEnterCount ++ === 0 ) {

					this.droppedItems = [];

					dropDOM.classList.add( 'visible' );

					this.add( dropNode );

				}

			} else if ( -- dropEnterCount === 0 ) {

				dropDOM.classList.remove( 'visible' );

				this.remove( dropNode );

			}

		};

		dom.addEventListener( 'dragenter', () => {

 			dragState( true );

		} );

		dom.addEventListener( 'dragleave', () => {

			dragState( false );

		} );

		dom.addEventListener( 'dragover', ( e ) => {

			e.preventDefault();

			const { relativeClientX, relativeClientY } = this;

			const centerNodeX = dropNode.getWidth() / 2;

			dropNode.setPosition( relativeClientX - centerNodeX, relativeClientY - 20 );

		} );

		dom.addEventListener( 'drop', ( e ) => {

			e.preventDefault();

			dragState( false );

			this.droppedItems = e.dataTransfer.items;

			dispatchEventList( this.events.drop, this );

		} );

		draggableDOM( dom, ( data ) => {

			const { delta, isTouch } = data;

			if ( ! isTouch ) {

				if ( data.scrollTop === undefined ) {

					data.scrollLeft = this.scrollLeft;
					data.scrollTop = this.scrollTop;

				}

				const zoom = this.zoom;

				this.scrollLeft = data.scrollLeft + ( delta.x / zoom );
				this.scrollTop = data.scrollTop + ( delta.y / zoom );

			}

			if ( data.dragging ) {

				dom.classList.add( 'grabbing' );

			} else {

				dom.classList.remove( 'grabbing' );

			}

		}, { className: 'dragging-canvas' } );


		draggableDOM( mapCanvas, ( data ) => {

			const { scale, screen } = this._mapInfo;

			if ( data.scrollLeft === undefined ) {

				const rect = this.mapCanvas.getBoundingClientRect();

				const clientMapX = data.client.x - rect.left;
				const clientMapY = data.client.y - rect.top;

				const overMapScreen =
					clientMapX > screen.x &amp;&amp; clientMapY > screen.y &amp;&amp;
					clientMapX &lt; screen.x + screen.width &amp;&amp; clientMapY &lt; screen.y + screen.height;

				if ( overMapScreen === false ) {

					const scaleX = this._mapInfo.width / this.mapCanvas.width;

					let scrollLeft = - this._mapInfo.left - ( clientMapX * scaleX );
					let scrollTop = - this._mapInfo.top - ( clientMapY * ( this._mapInfo.height / this.mapCanvas.height ) );

					scrollLeft += ( screen.width / 2 ) / scale;
					scrollTop += ( screen.height / 2 ) / scale;

					this.scrollLeft = scrollLeft;
					this.scrollTop = scrollTop;

				}

				data.scrollLeft = this.scrollLeft;
				data.scrollTop = this.scrollTop;

			}

			this.scrollLeft = data.scrollLeft - ( data.delta.x / scale );
			this.scrollTop = data.scrollTop - ( data.delta.y / scale );

		}, { click: true } );

		this._onMoveEvent = ( e ) => {

			const event = e.touches ? e.touches[ 0 ] : e;
			const { zoom, rect } = this;

			this.clientX = event.clientX;
			this.clientY = event.clientY;

			const rectClientX = ( this.clientX - rect.left ) / zoom;
			const rectClientY = ( this.clientY - rect.top ) / zoom;

			this.relativeClientX = rectClientX - this.scrollLeft;
			this.relativeClientY = rectClientY - this.scrollTop;

		};

		this._onUpdate = () => {

			this.update();

		};

		this.start();

	}

	getBounds() {

		const bounds = { x: Infinity, y: Infinity, width: - Infinity, height: - Infinity };

		for ( const node of this.nodes ) {

			const { x, y, width, height } = node.getBound();

			bounds.x = Math.min( bounds.x, x );
			bounds.y = Math.min( bounds.y, y );
			bounds.width = Math.max( bounds.width, x + width );
			bounds.height = Math.max( bounds.height, y + height );

		}

		bounds.x = Math.round( bounds.x );
		bounds.y = Math.round( bounds.y );
		bounds.width = Math.round( bounds.width );
		bounds.height = Math.round( bounds.height );

		return bounds;

	}

	get width() {

		return this._width;

	}

	get height() {

		return this._height;

	}

	get rect() {

		return this.dom.getBoundingClientRect();

	}

	get zoom() {

		return this._zoom;

	}

	set zoom( val ) {

		this._zoom = val;
		this.contentDOM.style.zoom = val;

	}

	set scrollLeft( val ) {

		this._scrollLeft = val;
		this.contentDOM.style.left = numberToPX( val );

	}

	get scrollLeft() {

		return this._scrollLeft;

	}

	set scrollTop( val ) {

		this._scrollTop = val;
		this.contentDOM.style.top = numberToPX( val );

	}

	get scrollTop() {

		return this._scrollTop;

	}

	set focusSelected( value ) {

		if ( this._focusSelected === value ) return;

		const classList = this.dom.classList;

		this._focusSelected = value;

		if ( value ) {

			classList.add( 'focusing' );

		} else {

			classList.remove( 'focusing' );

		}

	}

	get focusSelected() {

		return this._focusSelected;

	}

	onDrop( callback ) {

		this.events.drop.push( callback );

		return this;

	}

	start() {

		this.updating = true;

		document.addEventListener( 'wheel', this._onMoveEvent, true );

		document.addEventListener( 'mousedown', this._onMoveEvent, true );
		document.addEventListener( 'touchstart', this._onMoveEvent, true );

		document.addEventListener( 'mousemove', this._onMoveEvent, true );
		document.addEventListener( 'touchmove', this._onMoveEvent, true );

		document.addEventListener( 'dragover', this._onMoveEvent, true );

		requestAnimationFrame( this._onUpdate );

	}

	stop() {

		this.updating = false;

		document.removeEventListener( 'wheel', this._onMoveEvent, true );

		document.removeEventListener( 'mousedown', this._onMoveEvent, true );
		document.removeEventListener( 'touchstart', this._onMoveEvent, true );

		document.removeEventListener( 'mousemove', this._onMoveEvent, true );
		document.removeEventListener( 'touchmove', this._onMoveEvent, true );

		document.removeEventListener( 'dragover', this._onMoveEvent, true );

	}

	add( node ) {

		if ( node.canvas === this ) return;

		this.nodes.push( node );

		node.canvas = this;

		this.contentDOM.append( node.dom );

		return this;

	}

	remove( node ) {

		if ( node === this.selected ) {

			this.select();

		}

		this.unlink( node );

		const nodes = this.nodes;

		nodes.splice( nodes.indexOf( node ), 1 );

		node.canvas = null;

		this.contentDOM.removeChild( node.dom );

		node.dispatchEvent( new Event( 'remove' ) );

		return this;

	}

	clear() {

		const nodes = this.nodes;

		while ( nodes.length > 0 ) {

			this.remove( nodes[ 0 ] );

		}

		return this;

	}

	unlink( node ) {

		const links = this.getLinks();

		for ( const link of links ) {

			if ( link.inputElement &amp;&amp; link.outputElement ) {

				if ( link.inputElement.node === node ) {

					link.inputElement.connect();

				} else if ( link.outputElement.node === node ) {

					link.inputElement.connect();

				}

			}

		}

	}

	getLinks() {

		const links = [];

		for ( const node of this.nodes ) {

			links.push( ...node.getLinks() );

		}

		return links;

	}

	centralize() {

		const bounds = this.getBounds();

		this.scrollLeft = ( this.canvas.width / 2 ) - ( ( - bounds.x + bounds.width ) / 2 );
		this.scrollTop = ( this.canvas.height / 2 ) - ( ( - bounds.y + bounds.height ) / 2 );

		return this;

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		this.update();

		return this;

	}

	select( node = null ) {

		if ( node === this.selected ) return;

		const previousNode = this.selected;

		if ( previousNode !== null ) {

			this.focusSelected = false;

			previousNode.dom.classList.remove( 'selected' );

			this.selected = null;

			dispatchEventList( previousNode.events.blur, previousNode );

		}

		if ( node !== null ) {

			node.dom.classList.add( 'selected' );

			this.selected = node;

			dispatchEventList( node.events.focus, node );

		}

	}

	updateMap() {

		const { nodes, mapCanvas, mapContext, scrollLeft, scrollTop, canvas, zoom, _mapInfo } = this;

		const bounds = this.getBounds();

		mapCanvas.width = 300;
		mapCanvas.height = 200;

		mapContext.clearRect( 0, 0, mapCanvas.width, mapCanvas.height );

		mapContext.fillStyle = 'rgba( 0, 0, 0, 0 )';
		mapContext.fillRect( 0, 0, mapCanvas.width, mapCanvas.height );

		const boundsWidth = - bounds.x + bounds.width;
		const boundsHeight = - bounds.y + bounds.height;

		const mapScale = Math.min( mapCanvas.width / boundsWidth, mapCanvas.height / boundsHeight ) * .5;

		const boundsMapWidth = boundsWidth * mapScale;
		const boundsMapHeight = boundsHeight * mapScale;

		const boundsOffsetX = ( mapCanvas.width / 2 ) - ( boundsMapWidth / 2 );
		const boundsOffsetY = ( mapCanvas.height / 2 ) - ( boundsMapHeight / 2 );

		let selectedNode = null;

		for ( const node of nodes ) {

			const nodeBound = node.getBound();
			const nodeColor = node.getColor();

			nodeBound.x += - bounds.x;
			nodeBound.y += - bounds.y;

			nodeBound.x *= mapScale;
			nodeBound.y *= mapScale;
			nodeBound.width *= mapScale;
			nodeBound.height *= mapScale;

			nodeBound.x += boundsOffsetX;
			nodeBound.y += boundsOffsetY;

			if ( node !== this.selected ) {

				mapContext.fillStyle = nodeColor;
				mapContext.fillRect( nodeBound.x, nodeBound.y, nodeBound.width, nodeBound.height );

			} else {

				selectedNode = {
					nodeBound,
					nodeColor
				};

			}

		}

		if ( selectedNode !== null ) {

			const { nodeBound, nodeColor } = selectedNode;

			mapContext.fillStyle = nodeColor;
			mapContext.fillRect( nodeBound.x, nodeBound.y, nodeBound.width, nodeBound.height );

		}

		const screenMapX = ( - ( scrollLeft + bounds.x ) * mapScale ) + boundsOffsetX;
		const screenMapY = ( - ( scrollTop + bounds.y ) * mapScale ) + boundsOffsetY;
		const screenMapWidth = ( canvas.width * mapScale ) / zoom;
		const screenMapHeight = ( canvas.height * mapScale ) / zoom;

		mapContext.fillStyle = 'rgba( 200, 200, 200, 0.1 )';
		mapContext.fillRect( screenMapX, screenMapY, screenMapWidth, screenMapHeight );

		//

		_mapInfo.scale = mapScale;
		_mapInfo.left = ( - boundsOffsetX / mapScale ) + bounds.x;
		_mapInfo.top = ( - boundsOffsetY / mapScale ) + bounds.y;
		_mapInfo.width = mapCanvas.width / mapScale;
		_mapInfo.height = mapCanvas.height / mapScale;
		_mapInfo.screen.x = screenMapX;
		_mapInfo.screen.y = screenMapY;
		_mapInfo.screen.width = screenMapWidth;
		_mapInfo.screen.height = screenMapHeight;

	}

	updateLines() {

		const { dom, zoom, canvas, frontCanvas, frontContext, context, _width, _height } = this;

		const domRect = this.rect;

		if ( canvas.width !== _width || canvas.height !== _height ) {

			canvas.width = _width;
			canvas.height = _height;

			frontCanvas.width = _width;
			frontCanvas.height = _height;

		}

		context.clearRect( 0, 0, _width, _height );
		frontContext.clearRect( 0, 0, _width, _height );

		//

		context.globalCompositeOperation = 'lighter';
		frontContext.globalCompositeOperation = 'source-over';

		const links = this.getLinks();

		const aPos = { x: 0, y: 0 };
		const bPos = { x: 0, y: 0 };

		const offsetIORadius = 10;

		let dragging = '';

		for ( const link of links ) {

			const { lioElement, rioElement } = link;

			let draggingLink = '';
			let length = 0;

			if ( lioElement !== null ) {

				const rect = lioElement.dom.getBoundingClientRect();

				length = Math.max( length, lioElement.rioLength );

				aPos.x = rect.x + rect.width;
				aPos.y = rect.y + ( rect.height / 2 );

			} else {

				aPos.x = this.clientX;
				aPos.y = this.clientY;

				draggingLink = 'lio';

			}

			if ( rioElement !== null ) {

				const rect = rioElement.dom.getBoundingClientRect();

				length = Math.max( length, rioElement.lioLength );

				bPos.x = rect.x;
				bPos.y = rect.y + ( rect.height / 2 );

			} else {

				bPos.x = this.clientX;
				bPos.y = this.clientY;

				draggingLink = 'rio';

			}

			dragging = dragging || draggingLink;

			const drawContext = draggingLink ? frontContext : context;

			if ( draggingLink || length === 1 ) {

				let colorA = null,
					colorB = null;

				if ( draggingLink === 'rio' ) {

					colorA = colorB = lioElement.getRIOColor();

					aPos.x += offsetIORadius;
					bPos.x /= zoom;
					bPos.y /= zoom;

				} else if ( draggingLink === 'lio' ) {

					colorA = colorB = rioElement.getLIOColor();

					bPos.x -= offsetIORadius;
					aPos.x /= zoom;
					aPos.y /= zoom;

				} else {

					colorA = lioElement.getRIOColor();
					colorB = rioElement.getLIOColor();

				}

				drawLine(
					aPos.x * zoom, aPos.y * zoom,
					bPos.x * zoom, bPos.y * zoom,
					false, 2, colorA || '#ffffff', drawContext, colorB || '#ffffff'
				);

			} else {

				length = Math.min( length, 4 );

				for ( let i = 0; i &lt; length; i ++ ) {

					const color = colors[ i ] || '#ffffff';

					const marginY = 4;

					const rioLength = Math.min( lioElement.rioLength, length );
					const lioLength = Math.min( rioElement.lioLength, length );

					const colorA = lioElement.getRIOColor() || color;
					const colorB = rioElement.getLIOColor() || color;

					const aCenterY = ( ( rioLength * marginY ) * .5 ) - ( marginY / 2 );
					const bCenterY = ( ( lioLength * marginY ) * .5 ) - ( marginY / 2 );

					const aIndex = Math.min( i, rioLength - 1 );
					const bIndex = Math.min( i, lioLength - 1 );

					const aPosY = ( aIndex * marginY ) - 1;
					const bPosY = ( bIndex * marginY ) - 1;

					drawLine(
						aPos.x * zoom, ( ( aPos.y + aPosY ) - aCenterY ) * zoom,
						bPos.x * zoom, ( ( bPos.y + bPosY ) - bCenterY ) * zoom,
						false, 2, colorA, drawContext, colorB
					);

				}

			}

		}

		context.globalCompositeOperation = 'destination-in';

		context.fillRect( domRect.x, domRect.y, domRect.width, domRect.height );

		if ( dragging !== '' ) {

			dom.classList.add( 'dragging-' + dragging );

		} else {

			dom.classList.remove( 'dragging-lio' );
			dom.classList.remove( 'dragging-rio' );

		}

	}


	update() {

		if ( this.updating === false ) return;

		requestAnimationFrame( this._onUpdate );

		this.updateLines();
		this.updateMap();

	}

	serialize( data ) {

		const nodes = [];

		for ( const node of this.nodes ) {

			nodes.push( node.toJSON( data ).id );

		}

		data.nodes = nodes;

	}

	deserialize( data ) {

		for ( const id of data.nodes ) {

			this.add( data.objects[ id ] );

		}

	}

}

class ButtonInput extends Input {

	constructor( innterText = '' ) {

		const dom = document.createElement( 'button' );

		const spanDOM = document.createElement( 'span' );
		dom.append( spanDOM );

		const iconDOM = document.createElement( 'i' );
		dom.append( iconDOM );

		super( dom );

		this.spanDOM = spanDOM;
		this.iconDOM = iconDOM;

		spanDOM.innerText = innterText;

		dom.onmouseover = () => {

			this.dispatchEvent( new Event( 'mouseover' ) );

		};

		dom.onclick = dom.ontouchstart = ( e ) => {

			e.preventDefault();

			e.stopPropagation();

			this.dispatchEvent( new Event( 'click' ) );

		};

	}

	setIcon( className ) {

		this.iconDOM.className = className;

		return this;

	}

	setValue( val ) {

		this.spanDOM.innerText = val;

		return this;

	}

	getValue() {

		return this.spanDOM.innerText;

	}

}

class ObjectNode extends Node {

	constructor( name, inputLength, callback = null, width = 300 ) {

		super();

		this.setWidth( width );

		const title = new TitleElement( name )
			.setObjectCallback( callback )
			.setSerializable( false )
			.setOutput( inputLength );

		const closeButton = new ButtonInput( Styles.icons.close || '✕' ).onClick( () => {

			this.dispose();

		} ).setIcon( Styles.icons.close );

		title.addButton( closeButton );

		this.add( title );

		this.title = title;
		this.closeButton = closeButton;

	}

	setName( value ) {

		this.title.setTitle( value );

		return this;

	}

	getName() {

		return this.title.getTitle();

	}

	setObjectCallback( callback ) {

		this.title.setObjectCallback( callback );

		return this;

	}

	getObject( callback ) {

		return this.title.getObject( callback );

	}

	setColor( color ) {

		return this.title.setColor( color );

	}

	setOutputColor( color ) {

		return this.title.setOutputColor( color );

	}

	invalidate() {

		this.title.dispatchEvent( new Event( 'connect' ) );

	}

}

const ENTER_KEY$2 = 13;

class StringInput extends Input {

	constructor( value = '' ) {

		const dom = document.createElement( 'input' );
		super( dom );

		dom.type = 'text';
		dom.value = value;
		dom.spellcheck = false;
		dom.autocomplete = 'off';

		dom.onblur = () => {

			this.dispatchEvent( new Event( 'blur' ) );

		};

		dom.onchange = () => {

			this.dispatchEvent( new Event( 'change' ) );

		};

		dom.onkeyup = ( e ) => {

			if ( e.keyCode === ENTER_KEY$2 ) {

				e.target.blur();

			}

			e.stopPropagation();

			this.dispatchEvent( new Event( 'change' ) );

		};

	}

}

const ENTER_KEY$1 = 13;

class NumberInput extends Input {

	constructor( value = 0, min = - Infinity, max = Infinity, step = .01 ) {

		const dom = document.createElement( 'input' );
		super( dom );

		this.min = min;
		this.max = max;
		this.step = step;

		this.integer = false;

		dom.type = 'text';
		dom.className = 'number';
		dom.value = this._getString( value );
		dom.spellcheck = false;
		dom.autocomplete = 'off';

		dom.ondragstart = dom.oncontextmenu = ( e ) => {

			e.preventDefault();

			e.stopPropagation();

		};

		dom.onfocus = dom.onclick = () => {

			dom.select();

		};

		dom.onblur = () => {

			this.dom.value = this._getString( this.dom.value );

			this.dispatchEvent( new Event( 'blur' ) );

		};

		dom.onchange = () => {

			this.dispatchEvent( new Event( 'change' ) );

		};

		dom.onkeydown = ( e ) => {

			if ( e.key.length === 1 &amp;&amp; /\d|\./.test( e.key ) !== true ) {

				return false;

			}

			if ( e.keyCode === ENTER_KEY$1 ) {

				e.target.blur();

			}

			e.stopPropagation();

		};

		draggableDOM( dom, ( data ) => {

			const { delta } = data;

			if ( dom.readOnly === true ) return;

			if ( data.value === undefined ) {

				data.value = this.getValue();

			}

			const diff = delta.x - delta.y;

			const value = data.value + ( diff * this.step );

			dom.value = this._getString( value.toFixed( this.precision ) );

			this.dispatchEvent( new Event( 'change' ) );

		} );

	}

	setStep( step ) {

		this.step = step;

		return this;

	}

	setRange( min, max, step ) {

		this.min = min;
		this.max = max;
		this.step = step;

		this.dispatchEvent( new Event( 'range' ) );

		return this.setValue( this.getValue() );

	}

	get precision() {

		if ( this.integer === true ) return 0;

		const fract = this.step % 1;

		return fract !== 0 ? fract.toString().split( '.' )[ 1 ].length : 1;

	}

	setValue( val, dispatch = true ) {

		return super.setValue( this._getString( val ), dispatch );

	}

	getValue() {

		return Number( this.dom.value );

	}

	serialize( data ) {

		const { min, max } = this;

		if ( min !== - Infinity &amp;&amp; max !== Infinity ) {

			data.min = this.min;
			data.max = this.max;
			data.step = this.step;

		}

		super.serialize( data );

	}

	deserialize( data ) {

		if ( data.min !== undefined ) {

			const { min, max, step } = this;

			this.setRange( min, max, step );

		}

		super.deserialize( data );

	}

	_getString( value ) {

		const num = Math.min( Math.max( Number( value ), this.min ), this.max );

		if ( this.integer === true ) {

			return Math.floor( num );

		} else {

			return num + ( num % 1 ? '' : '.0' );

		}

	}

}

const getStep = ( min, max ) => {

	const sensibility = .001;

	return ( max - min ) * sensibility;

};

class SliderInput extends Input {

	constructor( value = 0, min = 0, max = 100 ) {

		const dom = document.createElement( 'f-subinputs' );
		super( dom );

		value = Math.min( Math.max( value, min ), max );

		const step = getStep( min, max );

		const rangeDOM = document.createElement( 'input' );
		rangeDOM.type = 'range';
		rangeDOM.min = min;
		rangeDOM.max = max;
		rangeDOM.step = step;
		rangeDOM.value = value;

		const field = new NumberInput( value, min, max, step );
		field.dom.className = 'range-value';
		field.onChange( () => {

			rangeDOM.value = field.getValue();

			this.dispatchEvent( new Event( 'change' ) );

		} );

		field.addEventListener( 'range', () => {

			rangeDOM.min = field.min;
			rangeDOM.max = field.max;
			rangeDOM.step = field.step;
			rangeDOM.value = field.getValue();

		} );

		dom.append( rangeDOM );
		dom.append( field.dom );

		this.rangeDOM = rangeDOM;
		this.field = field;

		const updateRangeValue = () => {

			let value = Number( rangeDOM.value );

			if ( value !== this.max &amp;&amp; value + this.step >= this.max ) {

				// fix not end range fraction

				rangeDOM.value = value = this.max;

			}

			this.field.setValue( value );

		};

		draggableDOM( rangeDOM, () => {

			updateRangeValue();

			this.dispatchEvent( new Event( 'change' ) );

		}, { className: '' } );

	}

	get min() {

		return this.field.min;

	}

	get max() {

		return this.field.max;

	}

	get step() {

		return this.field.step;

	}

	setRange( min, max ) {

		this.field.setRange( min, max, getStep( min, max ) );

		this.dispatchEvent( new Event( 'range' ) );
		this.dispatchEvent( new Event( 'change' ) );

		return this;

	}

	setValue( val, dispatch = true ) {

		this.field.setValue( val );
		this.rangeDOM.value = val;

		if ( dispatch ) this.dispatchEvent( new Event( 'change' ) );

		return this;

	}

	getValue() {

		return this.field.getValue();

	}

	serialize( data ) {

		data.min = this.min;
		data.max = this.max;

		super.serialize( data );

	}

	deserialize( data ) {

		const { min, max } = data;

		this.setRange( min, max );

		super.deserialize( data );

	}

}

class ColorInput extends Input {

	constructor( value = 0x0099ff ) {

		const dom = document.createElement( 'input' );
		super( dom );

		dom.type = 'color';
		dom.value = numberToHex( value );

		dom.oninput = () => {

			this.dispatchEvent( new Event( 'change' ) );

		};

	}

	setValue( value, dispatch = true ) {

		return super.setValue( numberToHex( value ), dispatch );

	}

	getValue() {

		return parseInt( super.getValue().substr( 1 ), 16 );

	}

}

const ENTER_KEY = 13;

class TextInput extends Input {

	constructor( innerText = '' ) {

		const dom = document.createElement( 'textarea' );
		super( dom );

		dom.innerText = innerText;

		dom.onblur = () => {

			this.dispatchEvent( new Event( 'blur' ) );

		};

		dom.onchange = () => {

			this.dispatchEvent( new Event( 'change' ) );

		};

		dom.onkeyup = ( e ) => {

			if ( e.keyCode === ENTER_KEY ) {

				e.target.blur();

			}

			e.stopPropagation();

			this.dispatchEvent( new Event( 'change' ) );

		};

	}

}

class LabelElement extends Element {

	constructor( label = '', align = '' ) {

		super();

		this.labelDOM = document.createElement( 'f-label' );
		this.inputsDOM = document.createElement( 'f-inputs' );

		const spanDOM = document.createElement( 'span' );

		this.spanDOM = spanDOM;
		this.iconDOM = null;

		this.labelDOM.append( spanDOM );

		this.dom.append( this.labelDOM );
		this.dom.append( this.inputsDOM );

		this.serializeLabel = false;

		this.setLabel( label );
		this.setAlign( align );

	}

	setIcon( value ) {

		this.iconDOM = this.iconDOM || document.createElement( 'i' );
		this.iconDOM.className = value;

		if ( value ) this.labelDOM.prepend( this.iconDOM );
		else this.iconDOM.remove();

		return this;

	}

	getIcon() {

		return this.iconDOM?.className;

	}

	setAlign( align ) {

		this.labelDOM.className = align;

	}

	setLabel( val ) {

		this.spanDOM.innerText = val;

	}

	getLabel() {

		return this.spanDOM.innerText;

	}

	serialize( data ) {

		super.serialize( data );

		if ( this.serializeLabel ) {

			const label = this.getLabel();
			const icon = this.getIcon();

			data.label = label;

			if ( icon !== '' ) {

				data.icon = icon;

			}

		}

	}

	deserialize( data ) {

		super.deserialize( data );

		if ( this.serializeLabel ) {

			this.setLabel( data.label );

			if ( data.icon !== undefined ) {

				this.setIcon( data.icon );

			}

		}

	}

}

class PanelNode extends Node {

	constructor( title = 'Panel', align = 'top-right' ) {

		super();

		const titleElement = new TitleElement( title );
		this.add( titleElement );

		const collapseButton = new ButtonInput( '🗕' );
		collapseButton.onClick( () => {

			this.setCollapse( ! this.collapsed );

		} );

		titleElement.addButton( collapseButton );

		this.collapseButton = collapseButton;
		this.titleElement = titleElement;
		this.align = align;
		this.collapsed = false;

		this.setAlign( align );
		this.setStyle( 'rouded' );

	}

	setCollapse( value ) {

		const cssClass = 'closed';

		this.dom.classList.remove( cssClass );

		this.collapsed = value;

		this.collapseButton.value = value ? '🗖' : '🗕';

		if ( value === true ) {

			this.dom.classList.add( cssClass );

		}

		return this;

	}

	setAlign( align ) {

		if ( this.align ) this.dom.classList.remove( this.align );
		this.dom.classList.add( align );

		this.align = align;

		return this;

	}

	addInput( inputClass, object, property, ...params ) {

		const value = object[ property ];

		const input = new inputClass( value, ...params );
		input.onChange( () => {

			object[ property ] = input.value;

		} );

		this.add( new LabelElement( property ).add( input ) );

		return input;

	}

	addSlider( object, property, min, max ) {

		return this.addInput( SliderInput, object, property, min, max );

	}

	addNumber( object, property ) {

		return this.addInput( NumberInput, object, property );

	}

	addColor( object, property ) {

		return this.addInput( ColorInput, object, property );

	}

	addString( object, property ) {

		return this.addInput( StringInput, object, property );

	}

	addText( object, property ) {

		const input = this.addInput( TextInput, object, property );
		input.element.setHeight( 70 );

		return input;

	}

	addButton( name ) {

		const input = new ButtonInput( name );

		this.add( new Element().setHeight( 34 ).add( input ) );

		return input;

	}

}

class Menu extends EventTarget {

	constructor( className ) {

		super();

		const dom = document.createElement( 'f-menu' );
		dom.className = className + ' bottom left hidden';

		const listDOM = document.createElement( 'f-list' );

		dom.append( listDOM );

		this.dom = dom;
		this.listDOM = listDOM;

		this.visible = false;

		this.align = 'bottom left';

		this.subMenus = new WeakMap();
		this.domButtons = new WeakMap();

		this.buttons = [];

		this.events = {};

	}

	onContext( callback ) {

		this.events.context.push( callback );

		return this;

	}

	setAlign( align ) {

		const dom = this.dom;

		removeDOMClass( dom, this.align );
		addDOMClass( dom, align );

		this.align = align;

		return this;

	}

	getAlign() {

		return this.align;

	}

	show() {

		this.dom.classList.remove( 'hidden' );

		this.visible = true;

		this.dispatchEvent( new Event( 'show' ) );

		return this;

	}

	hide() {

		this.dom.classList.add( 'hidden' );

		this.dispatchEvent( new Event( 'hide' ) );

		this.visible = false;

	}

	add( button, submenu = null ) {

		const liDOM = document.createElement( 'f-item' );

		if ( submenu !== null ) {

			liDOM.classList.add( 'submenu' );

			liDOM.append( submenu.dom );

			this.subMenus.set( button, submenu );

			button.dom.addEventListener( 'mouseover', () => submenu.show() );
			button.dom.addEventListener( 'mouseout', () => submenu.hide() );

		}

		liDOM.append( button.dom );

		this.buttons.push( button );

		this.listDOM.append( liDOM );

		this.domButtons.set( button, liDOM );

		return this;

	}

	clear() {

		this.buttons = [];

		this.subMenus = new WeakMap();
		this.domButtons = new WeakMap();

		while ( this.listDOM.firstChild ) {

			this.listDOM.firstChild.remove();

		}

	}

}

let lastContext = null;

const onCloseLastContext = ( e ) => {

	if ( lastContext &amp;&amp; lastContext.visible === true &amp;&amp; e.target.closest( 'f-menu.context' ) === null ) {

		lastContext.hide();

	}

};

document.body.addEventListener( 'mousedown', onCloseLastContext, true );
document.body.addEventListener( 'touchstart', onCloseLastContext, true );

class ContextMenu extends Menu {

	constructor( target = null ) {

		super( 'context', target );

		this.events.context = [];

		this._lastButtonClick = null;

		this._onButtonClick = ( e = null ) => {

			const button = e ? e.target : null;

			if ( this._lastButtonClick ) {

				this._lastButtonClick.dom.parentElement.classList.remove( 'active' );

			}

			this._lastButtonClick = button;

			if ( button ) {

				if ( this.subMenus.has( button ) ) {

					this.subMenus.get( button )._onButtonClick();

				}

				button.dom.parentElement.classList.add( 'active' );

			}

		};

		this._onButtonMouseOver = ( e ) => {

			const button = e.target;

			if ( this.subMenus.has( button ) &amp;&amp; this._lastButtonClick !== button ) {

				this._onButtonClick();

			}

		};

		this.addEventListener( 'context', ( ) => {

			dispatchEventList( this.events.context, this );

		} );

		this.setTarget( target );

	}

	openFrom( dom ) {

		const rect = dom.getBoundingClientRect();

		return this.open( rect.x + ( rect.width / 2 ), rect.y + ( rect.height / 2 ) );

	}

	open( x = pointer.x, y = pointer.y ) {

		if ( lastContext !== null ) {

			lastContext.hide();

		}

		lastContext = this;

		this.setPosition( x, y );

		document.body.append( this.dom );

		return this.show();

	}

	setPosition( x, y ) {

		const dom = this.dom;

		dom.style.left = numberToPX( x );
		dom.style.top = numberToPX( y );

		return this;

	}

	setTarget( target = null ) {

		if ( target !== null ) {

			const onContextMenu = ( e ) => {

				e.preventDefault();

				if ( e.pointerType !== 'mouse' || ( e.pageX === 0 &amp;&amp; e.pageY === 0 ) ) return;

				this.dispatchEvent( new Event( 'context' ) );

				this.open();

			};

			this.target = target;

			target.addEventListener( 'contextmenu', onContextMenu, false );

		}

		return this;

	}

	show() {

		if ( ! this.opened ) {

			this.dom.style.left = '';
			this.dom.style.transform = '';

		}

		const domRect = this.dom.getBoundingClientRect();

		let offsetX = Math.min( window.innerWidth - ( domRect.x + domRect.width + 10 ), 0 );
		let offsetY = Math.min( window.innerHeight - ( domRect.y + domRect.height + 10 ), 0 );

		if ( this.opened ) {

			if ( offsetX &lt; 0 ) offsetX = - domRect.width;
			if ( offsetY &lt; 0 ) offsetY = - domRect.height;

			this.setPosition( domRect.x + offsetX, domRect.y + offsetY );

		} else {

			// flip submenus

			if ( offsetX &lt; 0 ) this.dom.style.left = '-100%';
			if ( offsetY &lt; 0 ) this.dom.style.transform = 'translateY( calc( 32px - 100% ) )';

		}

		return super.show();

	}

	hide() {

		if ( this.opened ) {

			lastContext = null;

		}

		return super.hide();

	}

	add( button, submenu = null ) {

		button.addEventListener( 'click', this._onButtonClick );
		button.addEventListener( 'mouseover', this._onButtonMouseOver );

		return super.add( button, submenu );

	}

	get opened() {

		return lastContext === this;

	}

}

class CircleMenu extends Menu {

	constructor( target = null ) {

		super( 'circle', target );

	}

}

class Tips extends EventTarget {

	constructor() {

		super();

		const dom = document.createElement( 'f-tips' );

		this.dom = dom;

		this.time = 0;
		this.duration = 3000;

	}

	message( str ) {

		return this.tip( str );

	}

	error( str ) {

		return this.tip( str, 'error' );

	}

	tip( html, className = '' ) {

		const dom = document.createElement( 'f-tip' );
		dom.className = className;
		dom.innerHTML = html;

		this.dom.prepend( dom );

		//requestAnimationFrame( () => dom.style.opacity = 1 );

		this.time = Math.min( this.time + this.duration, this.duration );

		setTimeout( () => {

			this.time = Math.max( this.time - this.duration, 0 );

			dom.style.opacity = 0;

			setTimeout( () => dom.remove(), 250 );

		}, this.time );

		return this;

	}

}

const filterString = ( str ) => {

	return str.trim().toLowerCase().replace( /\s\s+/g, ' ' );

};

class Search extends Menu {

	constructor() {

		super( 'search' );

		this.events.submit = [];
		this.events.filter = [];

		this.tags = new WeakMap();

		const inputDOM = document.createElement( 'input' );
		inputDOM.placeholder = 'Type here';

		let filter = true;
		let filterNeedUpdate = true;

		inputDOM.addEventListener( 'focusout', () => {

			filterNeedUpdate = true;

			this.setValue( '' );

		} );

		inputDOM.onkeydown = ( e ) => {

			const keyCode = e.keyCode;

			if ( keyCode === 38 ) {

				const index = this.filteredIndex;

				if ( this.forceAutoComplete ) {

					this.filteredIndex = index !== null ? ( index + 1 ) % ( this.filtered.length || 1 ) : 0;

				} else {

					this.filteredIndex = index !== null ? Math.min( index + 1, this.filtered.length - 1 ) : 0;

				}

				e.preventDefault();

				filter = false;

			} else if ( keyCode === 40 ) {

				const index = this.filteredIndex;

				if ( this.forceAutoComplete ) {

					this.filteredIndex = index - 1;

					if ( this.filteredIndex === null ) this.filteredIndex = this.filtered.length - 1;

				} else {

					this.filteredIndex = index !== null ? index - 1 : null;

				}

				e.preventDefault();

				filter = false;

			} else if ( keyCode === 13 ) {

				this.value = this.currentFiltered ? this.currentFiltered.button.getValue() : inputDOM.value;

				this.submit();

				e.preventDefault();

				filter = false;

			} else {

				filter = true;

			}

		};

		inputDOM.onkeyup = () => {

			if ( filter ) {

				if ( filterNeedUpdate ) {

					this.dispatchEvent( new Event( 'filter' ) );

					filterNeedUpdate = false;

				}

				this.filter( inputDOM.value );

			}

		};

		this.filtered = [];
		this.currentFiltered = null;

		this.value = '';

		this.forceAutoComplete = false;

		this.dom.append( inputDOM );

		this.inputDOM = inputDOM;

		this.addEventListener( 'filter', ( ) => {

			dispatchEventList( this.events.filter, this );

		} );

		this.addEventListener( 'submit', ( ) => {

			dispatchEventList( this.events.submit, this );

		} );

	}

	submit() {

		this.dispatchEvent( new Event( 'submit' ) );

		return this.setValue( '' );

	}

	setValue( value ) {

		this.inputDOM.value = value;

		this.filter( value );

		return this;

	}

	getValue() {

		return this.value;

	}

	onFilter( callback ) {

		this.events.filter.push( callback );

		return this;

	}

	onSubmit( callback ) {

		this.events.submit.push( callback );

		return this;

	}

	getFilterByButton( button ) {

		for ( const filter of this.filtered ) {

			if ( filter.button === button ) {

				return filter;

			}

		}

		return null;

	}

	add( button ) {

		super.add( button );

		const onDown = () => {

			const filter = this.getFilterByButton( button );

			this.filteredIndex = this.filtered.indexOf( filter );
			this.value = button.getValue();

			this.submit();

		};

		button.dom.addEventListener( 'mousedown', onDown );
		button.dom.addEventListener( 'touchstart', onDown );

		this.domButtons.get( button ).remove();

		return this;

	}

	set filteredIndex( index ) {

		if ( this.currentFiltered ) {

			const buttonDOM = this.domButtons.get( this.currentFiltered.button );

			buttonDOM.classList.remove( 'active' );

			this.currentFiltered = null;

		}

		const filteredItem = this.filtered[ index ];

		if ( filteredItem ) {

			const buttonDOM = this.domButtons.get( filteredItem.button );

			buttonDOM.classList.add( 'active' );

			this.currentFiltered = filteredItem;

		}

		this.updateFilter();

	}

	get filteredIndex() {

		return this.currentFiltered ? this.filtered.indexOf( this.currentFiltered ) : null;

	}

	setTag( button, tags ) {

		this.tags.set( button, tags );

	}

	filter( text ) {

		text = filterString( text );

		const tags = this.tags;
		const filtered = [];

		for ( const button of this.buttons ) {

			const buttonDOM = this.domButtons.get( button );

			buttonDOM.remove();

			const buttonTags = tags.has( button ) ? ' ' + tags.get( button ) : '';

			const label = filterString( button.getValue() + buttonTags );

			if ( text &amp;&amp; label.includes( text ) === true ) {

				const score = text.length / label.length;

				filtered.push( {
					button,
					score
				} );

			}

		}

		filtered.sort( ( a, b ) => b.score - a.score );

		this.filtered = filtered;
		this.filteredIndex = this.forceAutoComplete ? 0 : null;

	}

	updateFilter() {

		const filteredIndex = Math.min( this.filteredIndex, this.filteredIndex - 3 );

		for ( let i = 0; i &lt; this.filtered.length; i ++ ) {

			const button = this.filtered[ i ].button;
			const buttonDOM = this.domButtons.get( button );

			buttonDOM.remove();

			if ( i >= filteredIndex ) {

				this.listDOM.append( buttonDOM );

			}

		}

	}

}

class SelectInput extends Input {

	constructor( options = [], value = null ) {

		const dom = document.createElement( 'select' );
		super( dom );

		dom.onchange = () => {

			this.dispatchEvent( new Event( 'change' ) );

		};

		dom.onmousedown = dom.ontouchstart = () => {

			this.dispatchEvent( new Event( 'click' ) );

		};

		this.setOptions( options, value );

	}

	setOptions( options, value = null ) {

		const dom = this.dom;
		const defaultValue = dom.value;

		let containsDefaultValue = false;

		this.options = options;
		dom.innerHTML = '';

		for ( let index = 0; index &lt; options.length; index ++ ) {

			let opt = options[ index ];

			if ( typeof opt === 'string' ) {

				opt = { name: opt, value: index };

			}

			const option = document.createElement( 'option' );
			option.innerText = opt.name;
			option.value = opt.value;

			if ( containsDefaultValue === false &amp;&amp; defaultValue === opt.value ) {

				containsDefaultValue = true;

			}

			dom.append( option );

		}

		dom.value = value !== null ? value : containsDefaultValue ? defaultValue : '';

		return this;

	}

	getOptions() {

		return this._options;

	}

	serialize( data ) {

		data.options = [ ...this.options ];

		super.serialize( data );

	}

	deserialize( data ) {

		const currentOptions = this.options;

		if ( currentOptions.length === 0 ) {

			this.setOptions( data.options );

		}

		super.deserialize( data );

	}

}

class ToggleInput extends Input {

	constructor( value = false ) {

		const dom = document.createElement( 'input' );
		super( dom );

		dom.type = 'checkbox';
		dom.className = 'toggle';
		dom.checked = value;

		dom.onclick = () => this.dispatchEvent( new Event( 'click' ) );
		dom.onchange = () => this.dispatchEvent( new Event( 'change' ) );

	}

	setValue( val ) {

		this.dom.checked = val;

		this.dispatchEvent( new Event( 'change' ) );

		return this;

	}

	getValue() {

		return this.dom.checked;

	}

}

var Flow = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Element: Element,
	Input: Input,
	Node: Node,
	Canvas: Canvas,
	Serializer: Serializer,
	Styles: Styles,
	ObjectNode: ObjectNode,
	PanelNode: PanelNode,
	Menu: Menu,
	ContextMenu: ContextMenu,
	CircleMenu: CircleMenu,
	Tips: Tips,
	Search: Search,
	DraggableElement: DraggableElement,
	LabelElement: LabelElement,
	TitleElement: TitleElement,
	ButtonInput: ButtonInput,
	ColorInput: ColorInput,
	NumberInput: NumberInput,
	SelectInput: SelectInput,
	SliderInput: SliderInput,
	StringInput: StringInput,
	TextInput: TextInput,
	ToggleInput: ToggleInput
});

class Loader extends EventTarget {

	constructor( parseType = Loader.DEFAULT ) {

		super();

		this.parseType = parseType;

		this.events = {
			'load': []
		};

	}

	setParseType( type ) {

		this.parseType = type;

		return this;

	}

	getParseType() {

		return this.parseType;

	}

	onLoad( callback ) {

		this.events.load.push( callback );

		return this;

	}

	async load( url, lib = null ) {

		return await fetch( url )
			.then( response => response.json() )
			.then( result => {

				this.data = this.parse( result, lib );

				dispatchEventList( this.events.load, this );

				return this.data;

			} )
			.catch( err => {

				console.error( 'Loader:', err );

			} );

	}

	parse( json, lib = null ) {

		json = this._parseObjects( json, lib );

		const parseType = this.parseType;

		if ( parseType === Loader.DEFAULT ) {

			const flowObj = new Flow[ json.type ]();

			if ( flowObj.getSerializable() ) {

				flowObj.deserialize( json );

			}

			return flowObj;

		} else if ( parseType === Loader.OBJECTS ) {

			return json;

		}

	}

	_parseObjects( json, lib = null ) {

		json = { ...json };

		const objects = {};

		for ( const id in json.objects ) {

			const obj = json.objects[ id ];
			obj.objects = objects;

			const Class = lib &amp;&amp; lib[ obj.type ] ? lib[ obj.type ] : Flow[ obj.type ];

			if ( ! Class ) {

				console.error( `Class "${ obj.type }" not found!` );

			}

			objects[ id ] = new Class();

		}

		const ref = new WeakMap();

		const deserializePass = ( prop = null ) => {

			for ( const id in json.objects ) {

				const newObject = objects[ id ];

				if ( ref.has( newObject ) === false &amp;&amp; ( prop === null || newObject[ prop ] === true ) ) {

					ref.set( newObject, true );

					if ( newObject.getSerializable() ) {

						newObject.deserialize( json.objects[ id ] );

					}

				}

			}

		};

		deserializePass( 'isNode' );
		deserializePass( 'isElement' );
		deserializePass( 'isInput' );
		deserializePass();

		json.objects = objects;

		return json;

	}

}

Loader.DEFAULT = 'default';
Loader.OBJECTS = 'objects';

export { ButtonInput, Canvas, CircleMenu, ColorInput, ContextMenu, DraggableElement, Element, Input, LabelElement, Loader, Menu, Node, NumberInput, ObjectNode, PanelNode, REVISION, Search, SelectInput, Serializer, SliderInput, StringInput, Styles, TextInput, Tips, TitleElement, ToggleInput, Utils };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-postcss-load-config.html">postcss-load-config</a></li></ul><h3>Namespaces</h3><ul><li><a href="opentype.html">opentype</a></li></ul><h3>Classes</h3><ul><li><a href="AMFLoader.html">AMFLoader</a></li><li><a href="AdaptiveToneMappingPass.html">AdaptiveToneMappingPass</a></li><li><a href="AnimationObjectGroup.html">AnimationObjectGroup</a></li><li><a href="ArcballControls.html">ArcballControls</a></li><li><a href="AsciiEffect.html">AsciiEffect</a></li><li><a href="AudioManager.html">AudioManager</a></li><li><a href="BVHLoader.html">BVHLoader</a></li><li><a href="BokehPass.html">BokehPass</a></li><li><a href="BooleanController.html">BooleanController</a></li><li><a href="BooleanKeyframeTrack.html">BooleanKeyframeTrack</a></li><li><a href="BulkUpdateDecorator.html">BulkUpdateDecorator</a></li><li><a href="CCDIKHelper.html">CCDIKHelper</a></li><li><a href="CCDIKSolver.html">CCDIKSolver</a></li><li><a href="CameraHelper.html">CameraHelper</a></li><li><a href="Chunk.html">Chunk</a></li><li><a href="ColladaExporter.html">ColladaExporter</a></li><li><a href="ColorController.html">ColorController</a></li><li><a href="ColorKeyframeTrack.html">ColorKeyframeTrack</a></li><li><a href="Component.html">Component</a></li><li><a href="Composer.html">Composer</a></li><li><a href="CompressedTextureLoader.html">CompressedTextureLoader</a></li><li><a href="Constraint.html">Constraint</a></li><li><a href="ContentDisposition.html">ContentDisposition</a></li><li><a href="Controller.html">Controller</a></li><li><a href="CubicInterpolant.html">CubicInterpolant</a></li><li><a href="Curve.html">Curve</a></li><li><a href="Cylindrical.html">Cylindrical</a></li><li><a href="DataTextureLoader.html">DataTextureLoader</a></li><li><a href="DecalGeometry.html">DecalGeometry</a></li><li><a href="DirEntry.html">DirEntry</a></li><li><a href="DiscreteInterpolant.html">DiscreteInterpolant</a></li><li><a href="EXRLoader.html">EXRLoader</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="ExtrudeGeometry.html">ExtrudeGeometry</a></li><li><a href="FSWatcher.html">FSWatcher</a></li><li><a href="Flow.html">Flow</a></li><li><a href="FunctionController.html">FunctionController</a></li><li><a href="GCodeLoader.html">GCodeLoader</a></li><li><a href="GLTFDracoMeshCompressionExtension.html">GLTFDracoMeshCompressionExtension</a></li><li><a href="GLTFLightExtension.html">GLTFLightExtension</a></li><li><a href="GLTFLightsExtension.html">GLTFLightsExtension</a></li><li><a href="GLTFMaterialsClearcoatExtension.html">GLTFMaterialsClearcoatExtension</a></li><li><a href="GLTFMaterialsEmissiveStrengthExtension.html">GLTFMaterialsEmissiveStrengthExtension</a></li><li><a href="GLTFMaterialsIorExtension.html">GLTFMaterialsIorExtension</a></li><li><a href="GLTFMaterialsIridescenceExtension.html">GLTFMaterialsIridescenceExtension</a></li><li><a href="GLTFMaterialsPBRSpecularGlossiness.html">GLTFMaterialsPBRSpecularGlossiness</a></li><li><a href="GLTFMaterialsSheenExtension.html">GLTFMaterialsSheenExtension</a></li><li><a href="GLTFMaterialsSpecularExtension.html">GLTFMaterialsSpecularExtension</a></li><li><a href="GLTFMaterialsTransmissionExtension.html">GLTFMaterialsTransmissionExtension</a></li><li><a href="GLTFMaterialsUnlitExtension.html">GLTFMaterialsUnlitExtension</a></li><li><a href="GLTFMaterialsVolumeExtension.html">GLTFMaterialsVolumeExtension</a></li><li><a href="GLTFMeshQuantizationExtension.html">GLTFMeshQuantizationExtension</a></li><li><a href="GLTFMeshStandardSGMaterial.html">GLTFMeshStandardSGMaterial</a></li><li><a href="GLTFMeshoptCompression.html">GLTFMeshoptCompression</a></li><li><a href="GLTFTextureBasisUExtension.html">GLTFTextureBasisUExtension</a></li><li><a href="GLTFTextureTransformExtension.html">GLTFTextureTransformExtension</a></li><li><a href="GLTFTextureWebPExtension.html">GLTFTextureWebPExtension</a></li><li><a href="GLTFWriter.html">GLTFWriter</a></li><li><a href="GPUComputationRenderer.html">GPUComputationRenderer</a></li><li><a href="GUI.html">GUI</a></li><li><a href="GenMapping.html">GenMapping</a></li><li><a href="GrannyKnot.html">GrannyKnot</a></li><li><a href="GrantSolver.html">GrantSolver</a></li><li><a href="GroundProjectedEnv.html">GroundProjectedEnv</a></li><li><a href="HalftonePass.html">HalftonePass</a></li><li><a href="InstancedFlow.html">InstancedFlow</a></li><li><a href="Interpolant.html">Interpolant</a></li><li><a href="KTXLoader.html">KTXLoader</a></li><li><a href="KhronosTextureContainer.html">KhronosTextureContainer</a></li><li><a href="Lexer.html">Lexer</a></li><li><a href="LineCounter.html">LineCounter</a></li><li><a href="MDDLoader.html">MDDLoader</a></li><li><a href="MMDAnimationHelper.html">MMDAnimationHelper</a></li><li><a href="MMDExporter.html">MMDExporter</a></li><li><a href="MMDLoader.html">MMDLoader</a></li><li><a href="MMDPhysics.html">MMDPhysics</a></li><li><a href="MMDPhysicsHelper.html">MMDPhysicsHelper</a></li><li><a href="MTLLoader.html">MTLLoader</a></li><li><a href="MarchingCubes.html">MarchingCubes</a></li><li><a href="MaterialBuilder.html">MaterialBuilder</a></li><li><a href="MaterialCreator.html">MaterialCreator</a></li><li><a href="MeshBuilder.html">MeshBuilder</a></li><li><a href="MotionController.html">MotionController</a></li><li><a href="NURBSCurve.html">NURBSCurve</a></li><li><a href="NURBSSurface.html">NURBSSurface</a></li><li><a href="NumberController.html">NumberController</a></li><li><a href="NumberControllerBox.html">NumberControllerBox</a></li><li><a href="NumberControllerSlider.html">NumberControllerSlider</a></li><li><a href="NumberKeyframeTrack.html">NumberKeyframeTrack</a></li><li><a href="OptionController.html">OptionController</a></li><li><a href="OutlineEffect.html">OutlineEffect</a></li><li><a href="PLYExporter.html">PLYExporter</a></li><li><a href="PMREMGenerator.html">PMREMGenerator</a></li><li><a href="PackedPhongMaterial.html">PackedPhongMaterial</a></li><li><a href="ParametricGeometry.html">ParametricGeometry</a></li><li><a href="Parser$1.html">Parser$1</a></li><li><a href="PeppersGhostEffect.html">PeppersGhostEffect</a></li><li><a href="ProgressiveLightMap.html">ProgressiveLightMap</a></li><li><a href="QuaternionKeyframeTrack.html">QuaternionKeyframeTrack</a></li><li><a href="QuaternionLinearInterpolant.html">QuaternionLinearInterpolant</a></li><li><a href="Query.html">Query</a></li><li><a href="RectAreaLightHelper.html">RectAreaLightHelper</a></li><li><a href="RectAreaLightUniformsLib.html">RectAreaLightUniformsLib</a></li><li><a href="ResourceManager.html">ResourceManager</a></li><li><a href="RigidBody.html">RigidBody</a></li><li><a href="RoomEnvironment.html">RoomEnvironment</a></li><li><a href="SAOPass.html">SAOPass</a></li><li><a href="SSAARenderPass.html">SSAARenderPass</a></li><li><a href="STLExporter.html">STLExporter</a></li><li><a href="STLLoader.html">STLLoader</a></li><li><a href="SetArray.html">SetArray</a></li><li><a href="ShadowMapViewer.html">ShadowMapViewer</a></li><li><a href="SimplexNoise.html">SimplexNoise</a></li><li><a href="Sky.html">Sky</a></li><li><a href="SourceMap$1.html">SourceMap$1</a></li><li><a href="Spherical.html">Spherical</a></li><li><a href="SphericalHarmonics3.html">SphericalHarmonics3</a></li><li><a href="StringController.html">StringController</a></li><li><a href="StringKeyframeTrack.html">StringKeyframeTrack</a></li><li><a href="TAARenderPass.html">TAARenderPass</a></li><li><a href="TDSLoader.html">TDSLoader</a></li><li><a href="TTFLoader.html">TTFLoader</a></li><li><a href="TeapotGeometry.html">TeapotGeometry</a></li><li><a href="TessellateModifier.html">TessellateModifier</a></li><li><a href="TextGeometry.html">TextGeometry</a></li><li><a href="ThreeMFLoader.html">ThreeMFLoader</a></li><li><a href="UnrealBloomPass.html">UnrealBloomPass</a></li><li><a href="VectorKeyframeTrack.html">VectorKeyframeTrack</a></li><li><a href="VisualResponse.html">VisualResponse</a></li><li><a href="Volume.html">Volume</a></li><li><a href="VolumeSlice.html">VolumeSlice</a></li><li><a href="WasmHash.html">WasmHash</a></li><li><a href="Water.html">Water</a></li><li><a href="WorkerPool.html">WorkerPool</a></li><li><a href="module-postcss-load-config-CloseEvent.html">CloseEvent</a></li><li><a href="module-postcss-load-config-DirEntry.html">DirEntry</a></li><li><a href="module-postcss-load-config-ErrorEvent.html">ErrorEvent</a></li><li><a href="module-postcss-load-config-Event.html">Event</a></li><li><a href="module-postcss-load-config-FSWatcher.html">FSWatcher</a></li><li><a href="module-postcss-load-config-Limiter$1.html">Limiter$1</a></li><li><a href="module-postcss-load-config-MessageEvent.html">MessageEvent</a></li><li><a href="module-postcss-load-config-ModuleNode.html">ModuleNode</a></li><li><a href="module-postcss-load-config-PerMessageDeflate$4.html">PerMessageDeflate$4</a></li><li><a href="module-postcss-load-config-Receiver$1.html">Receiver$1</a></li><li><a href="module-postcss-load-config-Sender$1.html">Sender$1</a></li><li><a href="module-postcss-load-config-WebSocket$1.html">WebSocket$1</a></li><li><a href="module-postcss-load-config-WebSocketServer.html">WebSocketServer</a></li><li><a href="opentype.BoundingBox.html">BoundingBox</a></li><li><a href="opentype.CffEncoding.html">CffEncoding</a></li><li><a href="opentype.CmapEncoding.html">CmapEncoding</a></li><li><a href="opentype.Coverage.html">Coverage</a></li><li><a href="opentype.DefaultEncoding.html">DefaultEncoding</a></li><li><a href="opentype.FeatureList.html">FeatureList</a></li><li><a href="opentype.Font.html">Font</a></li><li><a href="opentype.Glyph.html">Glyph</a></li><li><a href="opentype.GlyphNames.html">GlyphNames</a></li><li><a href="opentype.GlyphSet.html">GlyphSet</a></li><li><a href="opentype.Layout.html">Layout</a></li><li><a href="opentype.LookupList.html">LookupList</a></li><li><a href="opentype.Path.html">Path</a></li><li><a href="opentype.Position.html">Position</a></li><li><a href="opentype.Substitution.html">Substitution</a></li><li><a href="opentype.Table.html">Table</a></li><li><a href="opentype.decode.html">decode</a></li><li><a href="opentype.encode.html">encode</a></li><li><a href="opentype.sizeOf.html">sizeOf</a></li><li><a href="t.html">t</a></li></ul><h3>Mixins</h3><ul><li><a href="FsEventsHandler$1.html">FsEventsHandler$1</a></li><li><a href="NodeFsHandler$1.html">NodeFsHandler$1</a></li><li><a href="module-postcss-load-config-EventTarget.html">EventTarget</a></li><li><a href="module-postcss-load-config-FsEventsHandler$1.html">FsEventsHandler$1</a></li><li><a href="module-postcss-load-config-NodeFsHandler$1.html">NodeFsHandler$1</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#ACESFilmicToneMappingShader">ACESFilmicToneMappingShader</a></li><li><a href="global.html#ARR_EACH">ARR_EACH</a></li><li><a href="global.html#Accepts">Accepts</a></li><li><a href="global.html#AfterimageShader">AfterimageShader</a></li><li><a href="global.html#ArraySet">ArraySet</a></li><li><a href="global.html#AsyncDecompress">AsyncDecompress</a></li><li><a href="global.html#AsyncDeflate">AsyncDeflate</a></li><li><a href="global.html#AsyncGunzip">AsyncGunzip</a></li><li><a href="global.html#AsyncGzip">AsyncGzip</a></li><li><a href="global.html#AsyncInflate">AsyncInflate</a></li><li><a href="global.html#AsyncUnzipInflate">AsyncUnzipInflate</a></li><li><a href="global.html#AsyncUnzlib">AsyncUnzlib</a></li><li><a href="global.html#AsyncZipDeflate">AsyncZipDeflate</a></li><li><a href="global.html#AsyncZlib">AsyncZlib</a></li><li><a href="global.html#BOM">BOM</a></li><li><a href="global.html#BasicShader">BasicShader</a></li><li><a href="global.html#BasicSourceMapConsumer">BasicSourceMapConsumer</a></li><li><a href="global.html#Bidi">Bidi</a></li><li><a href="global.html#BleachBypassShader">BleachBypassShader</a></li><li><a href="global.html#BlendShader">BlendShader</a></li><li><a href="global.html#BokehShader">BokehShader</a></li><li><a href="global.html#BrightnessContrastShader">BrightnessContrastShader</a></li><li><a href="global.html#Buffer">Buffer</a></li><li><a href="global.html#Calculatesalldynamicvalues">Calculates all dynamic values</a></li><li><a href="global.html#CatmullRom">CatmullRom</a></li><li><a href="global.html#CharCodes%255Bundefined%255D">CharCodes[undefined]</a></li><li><a href="global.html#CharsetEncoder">CharsetEncoder</a></li><li><a href="global.html#ColorCorrectionShader">ColorCorrectionShader</a></li><li><a href="global.html#ColorifyShader">ColorifyShader</a></li><li><a href="global.html#Common">Common</a></li><li><a href="global.html#Constants">Constants</a></li><li><a href="global.html#ContextChecker">ContextChecker</a></li><li><a href="global.html#ContextRange">ContextRange</a></li><li><a href="global.html#ConvolutionShader">ConvolutionShader</a></li><li><a href="global.html#CopyShader">CopyShader</a></li><li><a href="global.html#DOCUMENT">DOCUMENT</a></li><li><a href="global.html#DOCUMENT_MODE">DOCUMENT_MODE</a></li><li><a href="global.html#DOFMipMapShader">DOFMipMapShader</a></li><li><a href="global.html#DOT_LITERAL">DOT_LITERAL</a></li><li><a href="global.html#DOUBLE_SLASH_RE$1">DOUBLE_SLASH_RE$1</a></li><li><a href="global.html#DataCreationHelper">DataCreationHelper</a></li><li><a href="global.html#DataViewEx">DataViewEx</a></li><li><a href="global.html#DecodeUTF8">DecodeUTF8</a></li><li><a href="global.html#Decompress">Decompress</a></li><li><a href="global.html#Deflate">Deflate</a></li><li><a href="global.html#DeprecationError">DeprecationError</a></li><li><a href="global.html#DepthLimitedBlurShader">DepthLimitedBlurShader</a></li><li><a href="global.html#DigitalGlitch">DigitalGlitch</a></li><li><a href="global.html#DotScreenShader">DotScreenShader</a></li><li><a href="global.html#Earcut">Earcut</a></li><li><a href="global.html#EncodeUTF8">EncodeUTF8</a></li><li><a href="global.html#Event">Event</a></li><li><a href="global.html#FIELD_NAME_REGEXP">FIELD_NAME_REGEXP</a></li><li><a href="global.html#FIRST_CHAR_REGEXP">FIRST_CHAR_REGEXP</a></li><li><a href="global.html#FLOW_END">FLOW_END</a></li><li><a href="global.html#FSEventsWatchers">FSEventsWatchers</a></li><li><a href="global.html#FS_PREFIX">FS_PREFIX</a></li><li><a href="global.html#FXAAShader">FXAAShader</a></li><li><a href="global.html#FeatureQuery">FeatureQuery</a></li><li><a href="global.html#FilmShader">FilmShader</a></li><li><a href="global.html#FocusShader">FocusShader</a></li><li><a href="global.html#FreiChenShader">FreiChenShader</a></li><li><a href="global.html#FsWatchInstances">FsWatchInstances</a></li><li><a href="global.html#GammaCorrectionShader">GammaCorrectionShader</a></li><li><a href="global.html#GodRaysCombineShader">GodRaysCombineShader</a></li><li><a href="global.html#GodRaysDepthMaskShader">GodRaysDepthMaskShader</a></li><li><a href="global.html#GodRaysFakeSunShader">GodRaysFakeSunShader</a></li><li><a href="global.html#GodRaysGenerateShader">GodRaysGenerateShader</a></li><li><a href="global.html#Gunzip">Gunzip</a></li><li><a href="global.html#Gzip">Gzip</a></li><li><a href="global.html#HalftoneShader">HalftoneShader</a></li><li><a href="global.html#HorizontalBlurShader">HorizontalBlurShader</a></li><li><a href="global.html#HorizontalTiltShiftShader">HorizontalTiltShiftShader</a></li><li><a href="global.html#HueSaturationShader">HueSaturationShader</a></li><li><a href="global.html#INFINITY">INFINITY</a></li><li><a href="global.html#IndexedSourceMapConsumer">IndexedSourceMapConsumer</a></li><li><a href="global.html#Inflate">Inflate</a></li><li><a href="global.html#Initializesframerelatedproperties.">Initializes frame related properties.</a></li><li><a href="global.html#Initializeshierarchyproperties">Initializes hierarchy properties</a></li><li><a href="global.html#KaleidoShader">KaleidoShader</a></li><li><a href="global.html#LuminosityHighPassShader">LuminosityHighPassShader</a></li><li><a href="global.html#LuminosityShader">LuminosityShader</a></li><li><a href="global.html#MATCHING_GROUP_REGEXP">MATCHING_GROUP_REGEXP</a></li><li><a href="global.html#MapSource">MapSource</a></li><li><a href="global.html#Mapping">Mapping</a></li><li><a href="global.html#MappingList">MappingList</a></li><li><a href="global.html#MirrorShader">MirrorShader</a></li><li><a href="global.html#NS">NS</a></li><li><a href="global.html#NULL_BYTE_PLACEHOLDER">NULL_BYTE_PLACEHOLDER</a></li><li><a href="global.html#Negotiator">Negotiator</a></li><li><a href="global.html#NormalMapShader">NormalMapShader</a></li><li><a href="global.html#OriginalSource">OriginalSource</a></li><li><a href="global.html#PARAM_REGEXP">PARAM_REGEXP</a></li><li><a href="global.html#POSIX_REGEX_SOURCE$1">POSIX_REGEX_SOURCE$1</a></li><li><a href="global.html#ParametricGeometries">ParametricGeometries</a></li><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#PixelShader">PixelShader</a></li><li><a href="global.html#QESC_REGEXP">QESC_REGEXP</a></li><li><a href="global.html#QUOTE_REGEXP">QUOTE_REGEXP</a></li><li><a href="global.html#REVISION">REVISION</a></li><li><a href="global.html#RGBShiftShader">RGBShiftShader</a></li><li><a href="global.html#Route">Route</a></li><li><a href="global.html#SAOShader">SAOShader</a></li><li><a href="global.html#SCALAR">SCALAR</a></li><li><a href="global.html#SMAAEdgesShader">SMAAEdgesShader</a></li><li><a href="global.html#SSAOShader">SSAOShader</a></li><li><a href="global.html#SSRShader">SSRShader</a></li><li><a href="global.html#SUBSTITUTIONS">SUBSTITUTIONS</a></li><li><a href="global.html#Searcheslayer'sparentingchain">Searches layer's parenting chain</a></li><li><a href="global.html#SepiaShader">SepiaShader</a></li><li><a href="global.html#Setslayerasparent.">Sets layer as parent.</a></li><li><a href="global.html#Setslayer'shierarchy.">Sets layer's hierarchy.</a></li><li><a href="global.html#SobelOperatorShader">SobelOperatorShader</a></li><li><a href="global.html#SourceMapGenerator">SourceMapGenerator</a></li><li><a href="global.html#SourceNode">SourceNode</a></li><li><a href="global.html#Symbol$1">Symbol$1</a></li><li><a href="global.html#TAG_ID">TAG_ID</a></li><li><a href="global.html#TYPE_REGEXP">TYPE_REGEXP</a></li><li><a href="global.html#TechnicolorShader">TechnicolorShader</a></li><li><a href="global.html#The">The</a></li><li><a href="global.html#Token">Token</a></li><li><a href="global.html#Tokenizer">Tokenizer</a></li><li><a href="global.html#ToneMapShader">ToneMapShader</a></li><li><a href="global.html#ToonShader1">ToonShader1</a></li><li><a href="global.html#TriangleBlurShader">TriangleBlurShader</a></li><li><a href="global.html#Types">Types</a></li><li><a href="global.html#UVsDebug">UVsDebug</a></li><li><a href="global.html#UniformsLib">UniformsLib</a></li><li><a href="global.html#UnpackDepthRGBAShader">UnpackDepthRGBAShader</a></li><li><a href="global.html#Unzip">Unzip</a></li><li><a href="global.html#UnzipInflate">UnzipInflate</a></li><li><a href="global.html#UnzipPassThrough">UnzipPassThrough</a></li><li><a href="global.html#Unzlib">Unzlib</a></li><li><a href="global.html#VALID_ID_PREFIX">VALID_ID_PREFIX</a></li><li><a href="global.html#VerticalBlurShader">VerticalBlurShader</a></li><li><a href="global.html#VerticalTiltShiftShader">VerticalTiltShiftShader</a></li><li><a href="global.html#View">View</a></li><li><a href="global.html#VignetteShader">VignetteShader</a></li><li><a href="global.html#Visible">Visible</a></li><li><a href="global.html#VolumeRenderShader1">VolumeRenderShader1</a></li><li><a href="global.html#WINDOWS_CHARS">WINDOWS_CHARS</a></li><li><a href="global.html#Zip">Zip</a></li><li><a href="global.html#ZipDeflate">ZipDeflate</a></li><li><a href="global.html#ZipPassThrough">ZipPassThrough</a></li><li><a href="global.html#Zlib">Zlib</a></li><li><a href="global.html#___$insertStyle">___$insertStyle</a></li><li><a href="global.html#__flow__addCSS">__flow__addCSS</a></li><li><a href="global.html#_cb">_cb</a></li><li><a href="global.html#_color">_color</a></li><li><a href="global.html#_face">_face</a></li><li><a href="global.html#_frustum">_frustum</a></li><li><a href="global.html#_position">_position</a></li><li><a href="global.html#_shadowMatrix">_shadowMatrix</a></li><li><a href="global.html#_taskCache">_taskCache</a></li><li><a href="global.html#acceptParams">acceptParams</a></li><li><a href="global.html#addEndtoBlockProps">addEndtoBlockProps</a></li><li><a href="global.html#addImportToGraph">addImportToGraph</a></li><li><a href="global.html#addMorphTargets">addMorphTargets</a></li><li><a href="global.html#addPrimitiveAttributes">addPrimitiveAttributes</a></li><li><a href="global.html#addSegment">addSegment</a></li><li><a href="global.html#alladdrs">alladdrs</a></li><li><a href="global.html#anchorIsValid">anchorIsValid</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#anymatch$1">anymatch$1</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#append">append</a></li><li><a href="global.html#application">application</a></li><li><a href="global.html#applyArabicPresentationForms">applyArabicPresentationForms</a></li><li><a href="global.html#applyArabicRequireLigatures">applyArabicRequireLigatures</a></li><li><a href="global.html#applyLatinLigatures">applyLatinLigatures</a></li><li><a href="global.html#applyReviver">applyReviver</a></li><li><a href="global.html#applySubstitution">applySubstitution</a></li><li><a href="global.html#arabicPresentationForms">arabicPresentationForms</a></li><li><a href="global.html#arabicRequiredLigatures">arabicRequiredLigatures</a></li><li><a href="global.html#arabicSentenceStartCheck">arabicSentenceStartCheck</a></li><li><a href="global.html#arabicWordStartCheck">arabicWordStartCheck</a></li><li><a href="global.html#arrayFlatten">arrayFlatten</a></li><li><a href="global.html#assignExtrasToUserData">assignExtrasToUserData</a></li><li><a href="global.html#axis">axis</a></li><li><a href="global.html#basePath">basePath</a></li><li><a href="global.html#bigEndianPlatform">bigEndianPlatform</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#bodyParser">bodyParser</a></li><li><a href="global.html#braces$1">braces$1</a></li><li><a href="global.html#braces$2">braces$2</a></li><li><a href="global.html#braces_1">braces_1</a></li><li><a href="global.html#buildSourceMapTree">buildSourceMapTree</a></li><li><a href="global.html#bytes">bytes</a></li><li><a href="global.html#callSiteLocation">callSiteLocation</a></li><li><a href="global.html#canvas">canvas</a></li><li><a href="global.html#canvasBuffer">canvasBuffer</a></li><li><a href="global.html#chainingSubstitutionFormat3">chainingSubstitutionFormat3</a></li><li><a href="global.html#chainingSubstitutionFormat3$1">chainingSubstitutionFormat3$1</a></li><li><a href="global.html#charset">charset</a></li><li><a href="global.html#checkGlyphIndexStatus">checkGlyphIndexStatus</a></li><li><a href="global.html#cleanOptions">cleanOptions</a></li><li><a href="global.html#cloneUniforms">cloneUniforms</a></li><li><a href="global.html#coerce">coerce</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#compareByGeneratedPositionsDeflated">compareByGeneratedPositionsDeflated</a></li><li><a href="global.html#compareByGeneratedPositionsInflated">compareByGeneratedPositionsInflated</a></li><li><a href="global.html#compareByOriginalPositions">compareByOriginalPositions</a></li><li><a href="global.html#compareGenerated">compareGenerated</a></li><li><a href="global.html#compileETag">compileETag</a></li><li><a href="global.html#compileQueryParser">compileQueryParser</a></li><li><a href="global.html#compileTrust">compileTrust</a></li><li><a href="global.html#compressNormals">compressNormals</a></li><li><a href="global.html#compressPositions">compressPositions</a></li><li><a href="global.html#compressUvs">compressUvs</a></li><li><a href="global.html#computeBounds">computeBounds</a></li><li><a href="global.html#computeMorphedAttributes">computeMorphedAttributes</a></li><li><a href="global.html#computeSourceURL">computeSourceURL</a></li><li><a href="global.html#consumeMoreIndentedLines">consumeMoreIndentedLines</a></li><li><a href="global.html#containsDotFile">containsDotFile</a></li><li><a href="global.html#containsNamespace">containsNamespace</a></li><li><a href="global.html#contentDisposition">contentDisposition</a></li><li><a href="global.html#contentRange">contentRange</a></li><li><a href="global.html#contentType">contentType</a></li><li><a href="global.html#contentstream">contentstream</a></li><li><a href="global.html#context">context</a></li><li><a href="global.html#convertDataDescriptorToAccessor">convertDataDescriptorToAccessor</a></li><li><a href="global.html#convertPatternsToTasks">convertPatternsToTasks</a></li><li><a href="global.html#createApplication">createApplication</a></li><li><a href="global.html#createArgumentsString">createArgumentsString</a></li><li><a href="global.html#createContext">createContext</a></li><li><a href="global.html#createDebug">createDebug</a></li><li><a href="global.html#createDefaultMaterial">createDefaultMaterial</a></li><li><a href="global.html#createError">createError</a></li><li><a href="global.html#createFSEventsInstance">createFSEventsInstance</a></li><li><a href="global.html#createFsWatchInstance">createFsWatchInstance</a></li><li><a href="global.html#createPattern">createPattern</a></li><li><a href="global.html#createScalarToken">createScalarToken</a></li><li><a href="global.html#createStackString">createStackString</a></li><li><a href="global.html#createWritableStdioStream">createWritableStdioStream</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#css">css</a></li><li><a href="global.html#ctx">ctx</a></li><li><a href="global.html#ctxBuffer">ctxBuffer</a></li><li><a href="global.html#currentlyResolving">currentlyResolving</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#debugMessage">debugMessage</a></li><li><a href="global.html#deburredLetters">deburredLetters</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#decodedMap">decodedMap</a></li><li><a href="global.html#decodedMappings">decodedMappings</a></li><li><a href="global.html#decompositionSubstitutionFormat1">decompositionSubstitutionFormat1</a></li><li><a href="global.html#decompressSync">decompressSync</a></li><li><a href="global.html#defaultComponentValues">defaultComponentValues</a></li><li><a href="global.html#defaultMessage">defaultMessage</a></li><li><a href="global.html#defineConfig">defineConfig</a></li><li><a href="global.html#deflateSync">deflateSync</a></li><li><a href="global.html#depd">depd</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#divmod32">divmod32</a></li><li><a href="global.html#dump">dump</a></li><li><a href="global.html#dynamicImport">dynamicImport</a></li><li><a href="global.html#emptyDir">emptyDir</a></li><li><a href="global.html#emptyTexture">emptyTexture</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#encloseBrace">encloseBrace</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodeUrl">encodeUrl</a></li><li><a href="global.html#encodedMap">encodedMap</a></li><li><a href="global.html#enter">enter</a></li><li><a href="global.html#equalArray">equalArray</a></li><li><a href="global.html#escapeAttribute">escapeAttribute</a></li><li><a href="global.html#escapeHtml">escapeHtml</a></li><li><a href="global.html#escapeNode">escapeNode</a></li><li><a href="global.html#escapeText">escapeText</a></li><li><a href="global.html#estimateBytesUsed">estimateBytesUsed</a></li><li><a href="global.html#etag">etag</a></li><li><a href="global.html#exceedsLimit">exceedsLimit</a></li><li><a href="global.html#expandRange">expandRange</a></li><li><a href="global.html#extendedparser">extendedparser</a></li><li><a href="global.html#extension">extension</a></li><li><a href="global.html#extractICSS$2">extractICSS$2</a></li><li><a href="global.html#fbxTree">fbxTree</a></li><li><a href="global.html#fd">fd</a></li><li><a href="global.html#fetchJsonFile">fetchJsonFile</a></li><li><a href="global.html#fieldContentRegExp">fieldContentRegExp</a></li><li><a href="global.html#fileRegex">fileRegex</a></li><li><a href="global.html#finalhandler">finalhandler</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findNewAnchor">findNewAnchor</a></li><li><a href="global.html#findNodes">findNodes</a></li><li><a href="global.html#first">first</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#flattenForever">flattenForever</a></li><li><a href="global.html#flattenWithDepth">flattenWithDepth</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#foldFlowLines">foldFlowLines</a></li><li><a href="global.html#foldNewline">foldNewline</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#formatColor">formatColor</a></li><li><a href="global.html#formatLocation">formatLocation</a></li><li><a href="global.html#formatPlain">formatPlain</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#forwarded">forwarded</a></li><li><a href="global.html#frameCorners">frameCorners</a></li><li><a href="global.html#freeGlobal">freeGlobal</a></li><li><a href="global.html#freeSelf">freeSelf</a></li><li><a href="global.html#fresh">fresh</a></li><li><a href="global.html#fromVLQSigned">fromVLQSigned</a></li><li><a href="global.html#fsWatchBroadcast">fsWatchBroadcast</a></li><li><a href="global.html#gameOver">gameOver</a></li><li><a href="global.html#generateTangents">generateTangents</a></li><li><a href="global.html#generatedPositionAfter">generatedPositionAfter</a></li><li><a href="global.html#genericNames">genericNames</a></li><li><a href="global.html#geometryNeedsUpdate">geometryNeedsUpdate</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getArg">getArg</a></li><li><a href="global.html#getCharset">getCharset</a></li><li><a href="global.html#getContextParams">getContextParams</a></li><li><a href="global.html#getContextParams$1">getContextParams$1</a></li><li><a href="global.html#getFirstKeyStartProps">getFirstKeyStartProps</a></li><li><a href="global.html#getLocalhostAddressIfDiffersFromDNS">getLocalhostAddressIfDiffersFromDNS</a></li><li><a href="global.html#getMinMax">getMinMax</a></li><li><a href="global.html#getPaddedArrayBuffer">getPaddedArrayBuffer</a></li><li><a href="global.html#getPaddedBufferSize">getPaddedBufferSize</a></li><li><a href="global.html#getPatternsInsideCurrentDirectory">getPatternsInsideCurrentDirectory</a></li><li><a href="global.html#getPatternsOutsideCurrentDirectory">getPatternsOutsideCurrentDirectory</a></li><li><a href="global.html#getRandomInt">getRandomInt</a></li><li><a href="global.html#getRawBody">getRawBody</a></li><li><a href="global.html#getStack">getStack</a></li><li><a href="global.html#getUniforms">getUniforms</a></li><li><a href="global.html#getcontenttype">getcontenttype</a></li><li><a href="global.html#globParent$1">globParent$1</a></li><li><a href="global.html#globParent$2">globParent$2</a></li><li><a href="global.html#gosper">gosper</a></li><li><a href="global.html#gunzipSync">gunzipSync</a></li><li><a href="global.html#gzipSync">gzipSync</a></li><li><a href="global.html#hasRequiredNode$1">hasRequiredNode$1</a></li><li><a href="global.html#hasbody">hasbody</a></li><li><a href="global.html#hilbert2D">hilbert2D</a></li><li><a href="global.html#hilbert3D">hilbert3D</a></li><li><a href="global.html#idToString">idToString</a></li><li><a href="global.html#index">index</a></li><li><a href="global.html#inflateSync">inflateSync</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initSplineTexture">initSplineTexture</a></li><li><a href="global.html#initializeCoreEvents">initializeCoreEvents</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#inspectorLog">inspectorLog</a></li><li><a href="global.html#interleaveAttributes">interleaveAttributes</a></li><li><a href="global.html#inverseMatrix">inverseMatrix</a></li><li><a href="global.html#isAbsolute">isAbsolute</a></li><li><a href="global.html#isArabicChar">isArabicChar</a></li><li><a href="global.html#isBigEndianPlatform">isBigEndianPlatform</a></li><li><a href="global.html#isCollection">isCollection</a></li><li><a href="global.html#isFileReadable">isFileReadable</a></li><li><a href="global.html#isFinished">isFinished</a></li><li><a href="global.html#isIdentityMatrix">isIdentityMatrix</a></li><li><a href="global.html#isInvalidBrace">isInvalidBrace</a></li><li><a href="global.html#isIsolatedArabicChar">isIsolatedArabicChar</a></li><li><a href="global.html#isLatinChar">isLatinChar</a></li><li><a href="global.html#isNonDriveRelativeAbsolutePath">isNonDriveRelativeAbsolutePath</a></li><li><a href="global.html#isOpenOrClose">isOpenOrClose</a></li><li><a href="global.html#isParentDirectory">isParentDirectory</a></li><li><a href="global.html#isScalar">isScalar</a></li><li><a href="global.html#isTashkeelArabicChar">isTashkeelArabicChar</a></li><li><a href="global.html#isWhiteSpace">isWhiteSpace</a></li><li><a href="global.html#is_reference">is_reference</a></li><li><a href="global.html#isignored">isignored</a></li><li><a href="global.html#isstats">isstats</a></li><li><a href="global.html#istraced">istraced</a></li><li><a href="global.html#join">join</a></li><li><a href="global.html#json">json</a></li><li><a href="global.html#keyPressed">keyPressed</a></li><li><a href="global.html#latinLigature">latinLigature</a></li><li><a href="global.html#latinWordStartCheck">latinWordStartCheck</a></li><li><a href="global.html#leave">leave</a></li><li><a href="global.html#ligatureSubstitutionFormat1">ligatureSubstitutionFormat1</a></li><li><a href="global.html#ligatureSubstitutionFormat1$1">ligatureSubstitutionFormat1$1</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadBushes1">loadBushes1</a></li><li><a href="global.html#loadCarriage">loadCarriage</a></li><li><a href="global.html#loadFromFile">loadFromFile</a></li><li><a href="global.html#loadFromUrl">loadFromUrl</a></li><li><a href="global.html#loadRoad">loadRoad</a></li><li><a href="global.html#loadTrees2">loadTrees2</a></li><li><a href="global.html#loadWalls">loadWalls</a></li><li><a href="global.html#loadWolf">loadWolf</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#lookup">lookup</a></li><li><a href="global.html#lookupCoverage">lookupCoverage</a></li><li><a href="global.html#lookupCoverageList">lookupCoverageList</a></li><li><a href="global.html#lowerThreshold">lowerThreshold</a></li><li><a href="global.html#lruMemoize">lruMemoize</a></li><li><a href="global.html#matchPatterns">matchPatterns</a></li><li><a href="global.html#matrix">matrix</a></li><li><a href="global.html#memoizedBinarySearch">memoizedBinarySearch</a></li><li><a href="global.html#merge">merge</a></li><li><a href="global.html#mergeBufferAttributes">mergeBufferAttributes</a></li><li><a href="global.html#mergeBufferGeometries">mergeBufferGeometries</a></li><li><a href="global.html#mergeVertices">mergeVertices</a></li><li><a href="global.html#mesh">mesh</a></li><li><a href="global.html#micromatch$1">micromatch$1</a></li><li><a href="global.html#micromatch_1">micromatch_1</a></li><li><a href="global.html#mime">mime</a></li><li><a href="global.html#ms$1">ms$1</a></li><li><a href="global.html#names">names</a></li><li><a href="global.html#nestedResolveFrom">nestedResolveFrom</a></li><li><a href="global.html#newObject">newObject</a></li><li><a href="global.html#node">node</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#normalizeAxes">normalizeAxes</a></li><li><a href="global.html#normalizeJsonSyntaxError">normalizeJsonSyntaxError</a></li><li><a href="global.html#normalizePath$5">normalizePath$5</a></li><li><a href="global.html#normalizeType">normalizeType</a></li><li><a href="global.html#normalizeTypes">normalizeTypes</a></li><li><a href="global.html#objectProto">objectProto</a></li><li><a href="global.html#objectToString">objectToString</a></li><li><a href="global.html#offset">offset</a></li><li><a href="global.html#onFinished">onFinished</a></li><li><a href="global.html#originalPositionFor">originalPositionFor</a></li><li><a href="global.html#originalPositionFor$1">originalPositionFor$1</a></li><li><a href="global.html#originalurl">originalurl</a></li><li><a href="global.html#paramRegExp">paramRegExp</a></li><li><a href="global.html#parameterCount">parameterCount</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parse$1">parse$1</a></li><li><a href="global.html#parse$f">parse$f</a></li><li><a href="global.html#parse$j">parse$j</a></li><li><a href="global.html#parseAllDocuments">parseAllDocuments</a></li><li><a href="global.html#parseBuffer">parseBuffer</a></li><li><a href="global.html#parseDocument">parseDocument</a></li><li><a href="global.html#parseOpenTypeTableEntries">parseOpenTypeTableEntries</a></li><li><a href="global.html#parseSexagesimal">parseSexagesimal</a></li><li><a href="global.html#parseSourceMapInput">parseSourceMapInput</a></li><li><a href="global.html#parseWOFFTableEntries">parseWOFFTableEntries</a></li><li><a href="global.html#parser">parser</a></li><li><a href="global.html#parsers">parsers</a></li><li><a href="global.html#parseurl">parseurl</a></li><li><a href="global.html#pathtoRegexp">pathtoRegexp</a></li><li><a href="global.html#picomatch">picomatch</a></li><li><a href="global.html#picomatch_1">picomatch_1</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#potpack">potpack</a></li><li><a href="global.html#preferredCharsets">preferredCharsets</a></li><li><a href="global.html#preferredEncodings">preferredEncodings</a></li><li><a href="global.html#preferredLanguages">preferredLanguages</a></li><li><a href="global.html#preferredMediaTypes">preferredMediaTypes</a></li><li><a href="global.html#prepareObjectStackTrace">prepareObjectStackTrace</a></li><li><a href="global.html#prettifyUrl">prettifyUrl</a></li><li><a href="global.html#prettyToken">prettyToken</a></li><li><a href="global.html#prevTime">prevTime</a></li><li><a href="global.html#processResult">processResult</a></li><li><a href="global.html#proto">proto</a></li><li><a href="global.html#proxyaddr">proxyaddr</a></li><li><a href="global.html#put">put</a></li><li><a href="global.html#qescRegExp">qescRegExp</a></li><li><a href="global.html#qstring">qstring</a></li><li><a href="global.html#quoteRegExp">quoteRegExp</a></li><li><a href="global.html#rangeParser">rangeParser</a></li><li><a href="global.html#rangeToPattern">rangeToPattern</a></li><li><a href="global.html#raw">raw</a></li><li><a href="global.html#rc">rc</a></li><li><a href="global.html#reApos">reApos</a></li><li><a href="global.html#reAsciiWord">reAsciiWord</a></li><li><a href="global.html#reComboMark">reComboMark</a></li><li><a href="global.html#reHasUnicode">reHasUnicode</a></li><li><a href="global.html#reHasUnicodeWord">reHasUnicodeWord</a></li><li><a href="global.html#reLatin">reLatin</a></li><li><a href="global.html#reUnicode">reUnicode</a></li><li><a href="global.html#reUnicodeWord">reUnicodeWord</a></li><li><a href="global.html#readByte">readByte</a></li><li><a href="global.html#readChunk">readChunk</a></li><li><a href="global.html#readColor">readColor</a></li><li><a href="global.html#readDWord">readDWord</a></li><li><a href="global.html#readFaceArray">readFaceArray</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#readFloat">readFloat</a></li><li><a href="global.html#readInt">readInt</a></li><li><a href="global.html#readMap">readMap</a></li><li><a href="global.html#readMaterialEntry">readMaterialEntry</a></li><li><a href="global.html#readMaterialGroup">readMaterialGroup</a></li><li><a href="global.html#readMesh">readMesh</a></li><li><a href="global.html#readMeshData">readMeshData</a></li><li><a href="global.html#readNamedObject">readNamedObject</a></li><li><a href="global.html#readPercentage">readPercentage</a></li><li><a href="global.html#readShort">readShort</a></li><li><a href="global.html#readStream">readStream</a></li><li><a href="global.html#readString">readString</a></li><li><a href="global.html#readWord">readWord</a></li><li><a href="global.html#readdirp$1">readdirp$1</a></li><li><a href="global.html#recursiveSearch">recursiveSearch</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#registerContextChecker">registerContextChecker</a></li><li><a href="global.html#relative">relative</a></li><li><a href="global.html#remapping">remapping</a></li><li><a href="global.html#removeDuplicateSlashes">removeDuplicateSlashes</a></li><li><a href="global.html#removedMiddlewares">removedMiddlewares</a></li><li><a href="global.html#replaceAll">replaceAll</a></li><li><a href="global.html#replacement">replacement</a></li><li><a href="global.html#req">req</a></li><li><a href="global.html#requestAnimationFrame">requestAnimationFrame</a></li><li><a href="global.html#res">res</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetObjects">resetObjects</a></li><li><a href="global.html#resolve$3">resolve$3</a></li><li><a href="global.html#reverseArabicSentences">reverseArabicSentences</a></li><li><a href="global.html#root$2">root$2</a></li><li><a href="global.html#rsApos">rsApos</a></li><li><a href="global.html#rsAstralRange">rsAstralRange</a></li><li><a href="global.html#rsLowerMisc">rsLowerMisc</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#scan$1">scan$1</a></li><li><a href="global.html#scan$2">scan$2</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#selectColor">selectColor</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#serializeOuter">serializeOuter</a></li><li><a href="global.html#serveStatic">serveStatic</a></li><li><a href="global.html#setAnchors">setAnchors</a></li><li><a href="global.html#setCharset">setCharset</a></li><li><a href="global.html#setFSEventsListener">setFSEventsListener</a></li><li><a href="global.html#setFsWatchFileListener">setFsWatchFileListener</a></li><li><a href="global.html#setFsWatchListener">setFsWatchListener</a></li><li><a href="global.html#setScalarValue">setScalarValue</a></li><li><a href="global.html#setSourceContent">setSourceContent</a></li><li><a href="global.html#setupScene">setupScene</a></li><li><a href="global.html#sha1">sha1</a></li><li><a href="global.html#should_remove">should_remove</a></li><li><a href="global.html#should_skip">should_skip</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#simpleparser">simpleparser</a></li><li><a href="global.html#singleSubstitutionFormat1">singleSubstitutionFormat1</a></li><li><a href="global.html#singleSubstitutionFormat1$1">singleSubstitutionFormat1$1</a></li><li><a href="global.html#singleSubstitutionFormat2">singleSubstitutionFormat2</a></li><li><a href="global.html#singleSubstitutionFormat2$1">singleSubstitutionFormat2$1</a></li><li><a href="global.html#sliceList">sliceList</a></li><li><a href="global.html#sortCache">sortCache</a></li><li><a href="global.html#spacing">spacing</a></li><li><a href="global.html#splitLines">splitLines</a></li><li><a href="global.html#splitType">splitType</a></li><li><a href="global.html#status">status</a></li><li><a href="global.html#strFromU8">strFromU8</a></li><li><a href="global.html#strToU8">strToU8</a></li><li><a href="global.html#stringToArrayBuffer">stringToArrayBuffer</a></li><li><a href="global.html#stringToPath">stringToPath</a></li><li><a href="global.html#stringify$2">stringify$2</a></li><li><a href="global.html#stringifyComment">stringifyComment</a></li><li><a href="global.html#stringifySexagesimal">stringifySexagesimal</a></li><li><a href="global.html#stripFilename">stripFilename</a></li><li><a href="global.html#subtypeNameRegExp">subtypeNameRegExp</a></li><li><a href="global.html#symbolProto">symbolProto</a></li><li><a href="global.html#symbolTag">symbolTag</a></li><li><a href="global.html#syntaxError">syntaxError</a></li><li><a href="global.html#syntaxError$1">syntaxError$1</a></li><li><a href="global.html#text">text</a></li><li><a href="global.html#tmpComponent">tmpComponent</a></li><li><a href="global.html#toIdentifier">toIdentifier</a></li><li><a href="global.html#toJS">toJS</a></li><li><a href="global.html#toRegexRange_1">toRegexRange_1</a></li><li><a href="global.html#toSetString">toSetString</a></li><li><a href="global.html#toTrianglesDrawMode">toTrianglesDrawMode</a></li><li><a href="global.html#toVLQSigned">toVLQSigned</a></li><li><a href="global.html#tokenType">tokenType</a></li><li><a href="global.html#tokenizeText">tokenizeText</a></li><li><a href="global.html#traceMappings">traceMappings</a></li><li><a href="global.html#traceSegment">traceSegment</a></li><li><a href="global.html#transformStableResult">transformStableResult</a></li><li><a href="global.html#triggerEvent">triggerEvent</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#typeChecker">typeChecker</a></li><li><a href="global.html#typeis">typeis</a></li><li><a href="global.html#typeofrequest">typeofrequest</a></li><li><a href="global.html#uncompressTable">uncompressTable</a></li><li><a href="global.html#unixify">unixify</a></li><li><a href="global.html#unpipe">unpipe</a></li><li><a href="global.html#unsign">unsign</a></li><li><a href="global.html#unwrapId">unwrapId</a></li><li><a href="global.html#unzip">unzip</a></li><li><a href="global.html#unzipSync">unzipSync</a></li><li><a href="global.html#unzlibSync">unzlibSync</a></li><li><a href="global.html#updateBushes1">updateBushes1</a></li><li><a href="global.html#updateCamera">updateCamera</a></li><li><a href="global.html#updateCarriage">updateCarriage</a></li><li><a href="global.html#updateMorphTargets">updateMorphTargets</a></li><li><a href="global.html#updateRoads">updateRoads</a></li><li><a href="global.html#updateSplineTexture">updateSplineTexture</a></li><li><a href="global.html#updateTrees2">updateTrees2</a></li><li><a href="global.html#updateWalls">updateWalls</a></li><li><a href="global.html#upperThreshold">upperThreshold</a></li><li><a href="global.html#urlRegex">urlRegex</a></li><li><a href="global.html#urlencoded">urlencoded</a></li><li><a href="global.html#useColors">useColors</a></li><li><a href="global.html#vary">vary</a></li><li><a href="global.html#visit">visit</a></li><li><a href="global.html#visit$1">visit$1</a></li><li><a href="global.html#visitAsync">visitAsync</a></li><li><a href="global.html#volume">volume</a></li><li><a href="global.html#walk$3">walk$3</a></li><li><a href="global.html#watch">watch</a></li><li><a href="global.html#wetag">wetag</a></li><li><a href="global.html#willConnectNext">willConnectNext</a></li><li><a href="global.html#willConnectPrev">willConnectPrev</a></li><li><a href="global.html#wrapId">wrapId</a></li><li><a href="global.html#wrapfunction">wrapfunction</a></li><li><a href="global.html#wrapproperty">wrapproperty</a></li><li><a href="global.html#xLength">xLength</a></li><li><a href="global.html#yLength">yLength</a></li><li><a href="global.html#zLength">zLength</a></li><li><a href="global.html#zip">zip</a></li><li><a href="global.html#zipSync">zipSync</a></li><li><a href="global.html#zlibSync">zlibSync</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Mon Nov 21 2022 21:10:05 GMT+0100 (Mitteleuropäische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
